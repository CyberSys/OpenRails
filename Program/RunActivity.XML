<?xml version="1.0"?>
<doc>
    <assembly>
        <name>RunActivity</name>
    </assembly>
    <members>
        <member name="T:ORTS.Light">
            <summary>
            The Light class encapsulates the data for each Light object 
            in the Lights block of an ENG/WAG file. 
            </summary>
        </member>
        <member name="T:ORTS.Lights">
            <summary>
            A Lights object is created for any engine or wagon having a 
            Lights block in its ENG/WAG file. It contains a collection of
            Light objects.
            Called from within the MSTSWagon class.
            </summary>
        </member>
        <member name="M:ORTS.Lights.ReadWagLights(MSTS.STFReader)">
            <summary>
            Reads the Lights block of an ENG/WAG file
            </summary>
        </member>
        <member name="T:ORTS.LightState">
            <summary>A LightState object encapsulates the data for each State in the States subblock.
            </summary>
        </member>
        <member name="M:ORTS.LightGlowDrawer.#ctor(ORTS.Viewer3D,ORTS.TrainCar,System.Boolean)">
            <summary>
            LightGlowDrawer constructor
            </summary>
        </member>
        <member name="M:ORTS.RenderPrimitive.Draw(Microsoft.Xna.Framework.Graphics.GraphicsDevice)">
            <summary>
            This is when the object actually renders itself onto the screen.
            Do not reference any volatile data.
            Executes in the RenderProcess thread
            </summary>
            <param name="graphicsDevice"></param>
        </member>
        <member name="M:ORTS.LightGlowMesh.#ctor(ORTS.RenderProcess,ORTS.TrainCar,System.Boolean)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:ORTS.LightGlowMesh.InitVertices">
            <summary>
            LightGlow light array intialization. 
            </summary>
        </member>
        <member name="T:ORTS.LightGlowVertex">
            <summary>
            Custom light glow vertex format.
            </summary>
        </member>
        <member name="M:ORTS.LightGlowVertex.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector4,Microsoft.Xna.Framework.Vector4)">
            <summary>
            Light glow vertex constructor.
            </summary>
            <param name="position">quad position</param>
            <param name="normal">quad normals</param>
            <param name="rgbcolor">rgb color</param>
            <param name="alphascaletex">color alpha, quad scale, texture coords</param>
            <param name="flags">headlight, unit, fadein, fadeout</param>
            TODO: Expand as needed for increased functionality
        </member>
        <member name="M:ORTS.WAVIrrKlangFileFactory.openFile(System.String)">
            <summary>
            IFileFactory Interface memeber to open the given file
            </summary>
            <param name="filename">Name of the file</param>
            <returns>The opened stream</returns>
        </member>
        <member name="M:ORTS.WAVIrrKlangFileFactory.isPlaying(System.String)">
            <summary>
            Check if a sound file is still playing
            </summary>
            <param name="FileName">Name of the file</param>
            <returns>True if still playing</returns>
        </member>
        <member name="M:ORTS.WAVIrrKlangFileFactory.Weigth(System.String)">
            <summary>
            Tries to find a suitable number to represent the Length
            </summary>
            <param name="FileName">Name of the file</param>
            <returns>The relative weight</returns>
        </member>
        <member name="M:ORTS.WAVIrrKlangFileFactory.StartLoopRelease(System.String)">
            <summary>
            Provide error free call to BeginLoop on Stream
            </summary>
            <param name="FileName">Name of the file, also key in dictionary</param>
        </member>
        <member name="M:ORTS.WAVIrrKlangFileFactory.StartLoop(System.String)">
            <summary>
            Provide error free call to BeginLoop on Stream
            </summary>
            <param name="FileName">Name of the file, also key in dictionary</param>
        </member>
        <member name="M:ORTS.WAVIrrKlangFileFactory.Release(System.String)">
            <summary>
            Provide error free call to Release on Stream
            </summary>
            <param name="FileName">Name of the file, also key in dictionary</param>
        </member>
        <member name="M:ORTS.WAVIrrKlangFileFactory.ReleaseWithJump(System.String)">
            <summary>
            Provide error free call to ReleaseWithJump on Stream
            </summary>
            <param name="FileName">Name of the file, also key in dictionary</param>
        </member>
        <member name="T:ORTS.WAVFileStream">
            <summary>
            File Stream implementation to provide CUE markers and looping functionality
            </summary>
        </member>
        <member name="M:ORTS.WAVFileStream.#ctor(System.String)">
            <summary>
            Contructor, resets loop information, also calls base constructor
            </summary>
            <param name="filename">Name of the file to be streamed</param>
        </member>
        <member name="M:ORTS.WAVFileStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Overriden Read, it handles basic info reading, also emulate loop
            </summary>
            <param name="array">Where to read bytes</param>
            <param name="offset">Offset in array</param>
            <param name="count">Number of bytes to read</param>
            <returns></returns>
        </member>
        <member name="M:ORTS.WAVFileStream.StartLoop">
            <summary>
            Sets loop begin, between markers
            </summary>
        </member>
        <member name="M:ORTS.WAVFileStream.Release">
            <summary>
            Set loop end, between markers
            </summary>
        </member>
        <member name="M:ORTS.WAVFileStream.ReleaseWithJump">
            <summary>
            Set loop end, between marker and end of file
            </summary>
        </member>
        <member name="M:ORTS.WAVFileStream.FromArray(System.Byte[])">
            <summary>
            Gets long from array of bytes
            </summary>
            <param name="array">byte array</param>
            <returns>The converted long</returns>
        </member>
        <member name="M:ORTS.WAVFileStream.FromReadArray(System.Int32)">
            <summary>
            Tries to read long from file
            </summary>
            <param name="len">Length of the long</param>
            <returns></returns>
        </member>
        <member name="M:ORTS.WAVFileStream.FindCUE">
            <summary>
            Finds CUE points, read the information
            </summary>
        </member>
        <member name="P:ORTS.WAVFileStream.LoopedLength">
            <summary>
            Gets looped length
            </summary>
        </member>
        <member name="P:ORTS.WAVFileStream.IsInternalLoop">
            <summary>
            Indicates if the Stream is in internal - between markers - loop
            </summary>
        </member>
        <member name="P:ORTS.WAVFileStream.BeginPosition">
            <summary>
            Gets the begin position in file, absolute or marker
            </summary>
        </member>
        <member name="P:ORTS.WAVFileStream.LoopedEndPosition">
            <summary>
            Gets the end position, marker or the absolute end
            </summary>
        </member>
        <member name="T:ORTS.CUE">
            <summary>
            Representing a CUE
            </summary>
        </member>
        <member name="T:ORTS.Camera">
            <summary>
            Base class for all cameras
            Represents a free roaming camera.
            </summary>
        </member>
        <member name="M:ORTS.Camera.Activate">
            <summary>
            Switches the <see cref="T:ORTS.Viewer3D"/> to this camera, updating the view information.
            </summary>
        </member>
        <member name="M:ORTS.Camera.OnActivate(System.Boolean)">
            <summary>
            A camera can use this method to handle any preparation when being activated.
            </summary>
        </member>
        <member name="M:ORTS.Camera.HandleUserInput(ORTS.ElapsedTime)">
            <summary>
            A camera can use this method to respond to user input.
            </summary>
            <param name="elapsedTime"></param>
        </member>
        <member name="M:ORTS.Camera.Update(ORTS.ElapsedTime)">
            <summary>
            A camera can use this method to update any calculated data that may have changed.
            </summary>
            <param name="elapsedTime"></param>
        </member>
        <member name="M:ORTS.Camera.GetCameraView">
            <summary>
            A camera should use this method to return a unique view.
            </summary>
        </member>
        <member name="M:ORTS.Camera.ScreenChanged">
            <summary>
            Notifies the camera that the screen dimensions have changed.
            </summary>
        </member>
        <member name="M:ORTS.Camera.PrepareFrame(ORTS.RenderFrame,ORTS.ElapsedTime)">
            <summary>
            Updates view and projection from this camera's data.
            </summary>
            <param name="frame"></param>
            <param name="elapsedTime"></param>
        </member>
        <member name="M:ORTS.Camera.CanSee(Microsoft.Xna.Framework.Vector3,System.Single,System.Single)">
            <summary>
            If the nearest part of the object is within camera viewing distance
            and is within the object's defined viewing distance then
            we can see it.   The objectViewingDistance allows a small object
            to specify a cutoff beyond which the object can't be seen.
            </summary>
        </member>
        <member name="M:ORTS.Camera.XNALocation(ORTS.WorldLocation)">
            <summary>
            Returns a position in XNA space relative to the camera's tile
            </summary>
            <param name="worldLocation"></param>
            <returns></returns>
        </member>
        <member name="T:ORTS.AttachedCamera">
            <summary>
            This represents a camera attached to a car.  
            It moves with the car.
            </summary>
        </member>
        <member name="T:ORTS.BrakemanCamera">
            <summary>
            The brakeman is on the car at the front or back
            TODO, allow brakeman to jump on or off cars
            </summary>
        </member>
        <member name="T:ORTS.HeadOutCamera">
            <summary>
            The brakeman is on the car at the front or back
            TODO, allow brakeman to jump on or off cars
            </summary>
        </member>
        <member name="M:ORTS.CabCamera.OnActivate(System.Boolean)">
            <summary>
            Make this the viewer's current camera.
            If the locomotive has no cab view, then do nothing.
            </summary>
        </member>
        <member name="P:ORTS.CabCamera.SideLocation">
            <summary>
            Gets the current camera location in CAB
            </summary>
        </member>
        <member name="M:ORTS.TrackingCamera.UpdateOnboardLocation">
            <summary>
            From distance and elevation variables
            </summary>
        </member>
        <member name="T:ORTS.MSTSDieselLocomotive">
            <summary>
            Adds physics and control for a diesel locomotive
            </summary>
        </member>
        <member name="T:ORTS.MSTSLocomotive">
            <summary>
            Adds Throttle, Direction, Horn, Sander and Wiper control
            to the basic TrainCar.
            Use as a base for Electric, Diesel or Steam locomotives.
            </summary>
        </member>
        <member name="T:ORTS.MSTSWagon">
            <summary>
            Represents the physical motion and behaviour of the car.
            </summary>
        </member>
        <member name="M:ORTS.MSTSWagon.InitializeFromWagFile(System.String)">
            <summary>
            This initializer is called when we haven't loaded this type of car before
            and must read it new from the wag file.
            </summary>
        </member>
        <member name="M:ORTS.MSTSWagon.Parse(System.String,MSTS.STFReader)">
            <summary>
            Parse the wag file parameters required for the simulator and viewer classes
            </summary>
        </member>
        <member name="M:ORTS.MSTSWagon.InitializeFromCopy(ORTS.MSTSWagon)">
            <summary>
            This initializer is called when we are making a new copy of a car already
            loaded in memory.  We use this one to speed up loading by eliminating the
            need to parse the wag file multiple times.
            
            IMPORTANT NOTE:  everything you initialized in parse, must be initialized here
            </summary>
        </member>
        <member name="M:ORTS.MSTSWagon.Save(System.IO.BinaryWriter)">
            <summary>
            We are saving the game.  Save anything that we'll need to restore the 
            status later.
            </summary>
        </member>
        <member name="M:ORTS.MSTSWagon.Restore(System.IO.BinaryReader)">
            <summary>
            We are restoring a saved game.  The TrainCar class has already
            been initialized.   Restore the game state.
            </summary>
        </member>
        <member name="M:ORTS.MSTSWagon.SignalEvent(ORTS.EventID)">
            <summary>
            Used when someone want to notify us of an event
            </summary>
        </member>
        <member name="M:ORTS.MSTSLocomotive.InitializeFromWagFile(System.String)">
            <summary>
            This initializer is called when we haven't loaded this type of car before
            and must read it new from the wag file.
            </summary>
        </member>
        <member name="M:ORTS.MSTSLocomotive.Parse(System.String,MSTS.STFReader)">
            <summary>
            Parse the wag file parameters required for the simulator and viewer classes
            </summary>
        </member>
        <member name="M:ORTS.MSTSLocomotive.InitializeFromCopy(ORTS.MSTSWagon)">
            <summary>
            This initializer is called when we are making a new copy of a car already
            loaded in memory.  We use this one to speed up loading by eliminating the
            need to parse the wag file multiple times.
            </summary>
        </member>
        <member name="M:ORTS.MSTSLocomotive.Save(System.IO.BinaryWriter)">
            <summary>
            We are saving the game.  Save anything that we'll need to restore the 
            status later.
            </summary>
        </member>
        <member name="M:ORTS.MSTSLocomotive.Restore(System.IO.BinaryReader)">
            <summary>
            We are restoring a saved game.  The TrainCar class has already
            been initialized.   Restore the game state.
            </summary>
        </member>
        <member name="M:ORTS.MSTSLocomotive.GetViewer(ORTS.Viewer3D)">
            <summary>
            Create a viewer for this locomotive.   Viewers are only attached
            while the locomotive is in viewing range.
            </summary>
        </member>
        <member name="M:ORTS.MSTSLocomotive.Update(System.Single)">
            <summary>
            This is a periodic update to calculate physics 
            parameters and update the base class's MotiveForceN 
            and FrictionForceN values based on throttle settings
            etc for the locomotive.
            </summary>
        </member>
        <member name="M:ORTS.MSTSLocomotive.LimitMotiveForce">
            <summary>
            Adjusts the MotiveForce to account for adhesion limits
            The basic force limits are calculated the same way MSTS calculates them, but
            the weather handleing is different
            </summary>
        </member>
        <member name="M:ORTS.MSTSLocomotive.SignalEvent(ORTS.EventID)">
            <summary>
            Used when someone want to notify us of an event
            </summary>
        </member>
        <member name="M:ORTS.MSTSLocomotive.GetDataOf(MSTS.CabViewControl)">
            <summary>
            Gets the Locomotive data needed by the Cav View Control
            Check here for Signal display
            </summary>
            <param name="cvc">The Cab View Control</param>
            <returns>The data converted to the requested unit</returns>
        </member>
        <member name="M:ORTS.MSTSDieselLocomotive.Parse(System.String,MSTS.STFReader)">
            <summary>
            Parse the wag file parameters required for the simulator and viewer classes
            </summary>
        </member>
        <member name="M:ORTS.MSTSDieselLocomotive.InitializeFromCopy(ORTS.MSTSWagon)">
            <summary>
            This initializer is called when we are making a new copy of a car already
            loaded in memory.  We use this one to speed up loading by eliminating the
            need to parse the wag file multiple times.
            NOTE:  you must initialize all the same variables as you parsed above
            </summary>
        </member>
        <member name="M:ORTS.MSTSDieselLocomotive.Save(System.IO.BinaryWriter)">
            <summary>
            We are saving the game.  Save anything that we'll need to restore the 
            status later.
            </summary>
        </member>
        <member name="M:ORTS.MSTSDieselLocomotive.Restore(System.IO.BinaryReader)">
            <summary>
            We are restoring a saved game.  The TrainCar class has already
            been initialized.   Restore the game state.
            </summary>
        </member>
        <member name="M:ORTS.MSTSDieselLocomotive.GetViewer(ORTS.Viewer3D)">
            <summary>
            Create a viewer for this locomotive.   Viewers are only attached
            while the locomotive is in viewing range.
            </summary>
        </member>
        <member name="M:ORTS.MSTSDieselLocomotive.Update(System.Single)">
            <summary>
            This is a periodic update to calculate physics 
            parameters and update the base class's MotiveForceN 
            and FrictionForceN values based on throttle settings
            etc for the locomotive.
            </summary>
        </member>
        <member name="M:ORTS.MSTSDieselLocomotive.SignalEvent(ORTS.EventID)">
            <summary>
            Used when someone want to notify us of an event
            </summary>
        </member>
        <member name="T:ORTS.MSTSDieselLocomotiveViewer">
            <summary>
            Adds any special Diesel loco animation to the basic LocomotiveViewer class
            </summary>
        </member>
        <member name="T:ORTS.MSTSLocomotiveViewer">
            <summary>
            Adds animation for wipers to the basic TrainCar
            </summary>
        </member>
        <member name="T:ORTS.MSTSWagonViewer">
            <summary>
            Note:  we need a separate viewer class since there could be multiple viewers
            for a single traincar, or possibly none
            </summary>
        </member>
        <member name="M:ORTS.TrainCarViewer.PrepareFrame(ORTS.RenderFrame,ORTS.ElapsedTime)">
            <summary>
            Called at the full frame rate
            elapsedTime is time since last frame
            Executes in the UpdaterThread
            </summary>
        </member>
        <member name="M:ORTS.MSTSWagonViewer.PrepareFrame(ORTS.RenderFrame,ORTS.ElapsedTime)">
            <summary>
            Called at the full frame rate
            elapsedTime is time since last frame
            Executes in the UpdaterThread
            </summary>
        </member>
        <member name="M:ORTS.MSTSWagonViewer.Unload">
            <summary>
            Unload and release the car - its not longer being displayed
            </summary>
        </member>
        <member name="M:ORTS.MSTSWagonViewer.LoadCarSounds(System.String)">
            <summary>
            Load the various car sounds
            </summary>
            <param name="wagonFolderSlash"></param>
        </member>
        <member name="M:ORTS.MSTSWagonViewer.LoadCarSound(System.String,System.String)">
            <summary>
            Load the car sound, attach it to the car
            check first in the wagon folder, then the global folder for the sound.
            If not found, report a warning.
            </summary>
            <param name="wagonFolderSlash"></param>
            <param name="filename"></param>
        </member>
        <member name="M:ORTS.MSTSWagonViewer.LoadTrackSounds">
            <summary>
            Load the inside and outside sounds for the default level 0 track type.
            </summary>
        </member>
        <member name="M:ORTS.MSTSWagonViewer.LoadTrackSound(System.String)">
            <summary>
            Load the sound source, attach it to the car.
            Check first in route\SOUND folder, then in base\SOUND folder.
            </summary>
            <param name="filename"></param>
        </member>
        <member name="M:ORTS.MSTSLocomotiveViewer.HandleUserInput(ORTS.ElapsedTime)">
            <summary>
            A keyboard or mouse click has occurred. Read the UserInput
            structure to determine what was pressed.
            </summary>
        </member>
        <member name="M:ORTS.MSTSLocomotiveViewer.PrepareFrame(ORTS.RenderFrame,ORTS.ElapsedTime)">
            <summary>
            We are about to display a video frame.  Calculate positions for 
            animated objects, and add their primitives to the RenderFrame list.
            </summary>
        </member>
        <member name="M:ORTS.MSTSLocomotiveViewer.Unload">
            <summary>
            This doesn't function yet.
            </summary>
        </member>
        <member name="M:ORTS.MSTSDieselLocomotiveViewer.HandleUserInput(ORTS.ElapsedTime)">
            <summary>
            A keyboard or mouse click has occured. Read the UserInput
            structure to determine what was pressed.
            </summary>
        </member>
        <member name="M:ORTS.MSTSDieselLocomotiveViewer.PrepareFrame(ORTS.RenderFrame,ORTS.ElapsedTime)">
            <summary>
            We are about to display a video frame.  Calculate positions for 
            animated objects, and add their primitives to the RenderFrame list.
            </summary>
        </member>
        <member name="M:ORTS.MSTSDieselLocomotiveViewer.Unload">
            <summary>
            This doesn't function yet.
            </summary>
        </member>
        <member name="T:ORTS.Debugging.DebugViewerForm">
            <summary>
            Defines an external window for use as a debugging viewer 
            when using Open Rails 
            </summary>
        </member>
        <member name="F:ORTS.Debugging.DebugViewerForm.simulator">
            <summary>
            Reference to the main simulator object.
            </summary>
        </member>
        <member name="F:ORTS.Debugging.DebugViewerForm.viewer">
            <summary>
            Reference to the Viewer3D object.
            </summary>
        </member>
        <member name="F:ORTS.Debugging.DebugViewerForm.LeftButtonDown">
            <summary>
            True when the user has the "Move left" pressed.
            </summary>
        </member>
        <member name="F:ORTS.Debugging.DebugViewerForm.RightButtonDown">
            <summary>
            True when the user has the "Move right" pressed.
            </summary>
        </member>
        <member name="F:ORTS.Debugging.DebugViewerForm.UpButtonDown">
            <summary>
            True when the user has the "Move up" pressed.
            </summary>
        </member>
        <member name="F:ORTS.Debugging.DebugViewerForm.DownButtonDown">
            <summary>
            True when the user has the "Move down" pressed.
            </summary>
        </member>
        <member name="F:ORTS.Debugging.DebugViewerForm.ViewWindow">
            <summary>
            Defines the area to view, in meters.
            </summary>
        </member>
        <member name="F:ORTS.Debugging.DebugViewerForm.UITimer">
            <summary>
            Used to periodically check if we should shift the view when the
            user is holding down a "shift view" button.
            </summary>
        </member>
        <member name="M:ORTS.Debugging.DebugViewerForm.#ctor(ORTS.Simulator,ORTS.Viewer3D)">
            <summary>
            Creates a new DebugViewerForm.
            </summary>
            <param name="simulator"></param>
            /// <param name="viewer"></param>
        </member>
        <member name="M:ORTS.Debugging.DebugViewerForm.UITimer_Tick(System.Object,System.EventArgs)">
            <summary>
            When the user holds down the  "L", "R", "U", "D" buttons,
            shift the view. Avoids the case when the user has to click
            buttons like crazy.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:ORTS.Debugging.DebugViewerForm.InitImage">
            <summary>
            Initialises the picturebox and the image it contains. 
            </summary>
        </member>
        <member name="M:ORTS.Debugging.DebugViewerForm.GenerateView">
            <summary>
            Regenerates the 2D view. At the moment, examines the track network
            each time the view is drawn. Later, the traversal and drawing can be separated.
            </summary>
        </member>
        <member name="M:ORTS.Debugging.DebugViewerForm.GetRect(System.Drawing.PointF,System.Single)">
            <summary>
            Generates a rectangle representing a dot being drawn.
            </summary>
            <param name="p">Center point of the dot, in pixels.</param>
            <param name="size">Size of the dot's diameter, in pixels</param>
            <returns></returns>
        </member>
        <member name="M:ORTS.Debugging.DebugViewerForm.AddSegments(System.Collections.Generic.List{ORTS.Debugging.LineSegment},MSTS.TrackNode,MSTS.TrVectorSection[],System.Single@,System.Single@,System.Single@,System.Single@,ORTS.Simulator)">
            <summary>
            Generates line segments from an array of TrVectorSection. Also computes 
            the bounds of the entire route being drawn.
            </summary>
            <param name="segments"></param>
            <param name="items"></param>
            <param name="minX"></param>
            <param name="minY"></param>
            <param name="maxX"></param>
            <param name="maxY"></param>
            <param name="simulator"></param>
        </member>
        <member name="M:ORTS.Debugging.DebugViewerForm.CalcBounds(System.Single@,System.Single,System.Boolean)">
            <summary>
            Given a value representing a limit, evaluate if the given value exceeds the current limit.
            If so, expand the limit.
            </summary>
            <param name="limit">The current limit.</param>
            <param name="value">The value to compare the limit to.</param>
            <param name="gt">True when comparison is greater-than. False if less-than.</param>
        </member>
        <member name="F:ORTS.Debugging.DebugViewerForm.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:ORTS.Debugging.DebugViewerForm.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:ORTS.Debugging.DebugViewerForm.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:ORTS.Debugging.SignalWidget">
            <summary>
            Defines a signal being drawn in a 2D view.
            </summary>
        </member>
        <member name="F:ORTS.Debugging.SignalWidget.Item">
            <summary>
            The underlying track item.
            </summary>
        </member>
        <member name="F:ORTS.Debugging.SignalWidget.Signal">
            <summary>
            The underlying signal object as referenced by the TrItem.
            </summary>
        </member>
        <member name="M:ORTS.Debugging.SignalWidget.#ctor(MSTS.TrItem,ORTS.SignalObject)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="signal"></param>
        </member>
        <member name="P:ORTS.Debugging.SignalWidget.IsProceed">
            <summary>
            For now, returns true if any of the signal heads shows any "clear" aspect.
            This obviously needs some refinement.
            </summary>
        </member>
        <member name="T:ORTS.Debugging.LineSegment">
            <summary>
            Defines a geometric line segment.
            </summary>
        </member>
        <member name="M:ORTS.TrackAuthority.CalcStopDistance">
            <summary>
            Computes the StopDistanceM value, i.e. the distance from one end of the train to the StopNode.
            </summary>
        </member>
        <member name="M:ORTS.TrackAuthority.AdvanceStopNode(System.Boolean)">
            <summary>
            Moves the StopNode to the next path node the train should stop at.
            </summary>
        </member>
        <member name="T:MSTS.SharedSMSFileManager">
            <summary>
            Utility class to avoid loading multiple copies of the same file.
            </summary>
        </member>
        <member name="T:MSTS.SMSFile">
            <summary>
            Represents the hiearchical structure of the SMS File
            </summary>
        </member>
        <member name="M:ORTS.DynatrackDrawer.#ctor(ORTS.Viewer3D,MSTS.DyntrackObj,ORTS.WorldPosition,ORTS.WorldPosition)">
            <summary>
            DynatrackDrawer constructor
            </summary>
        </member>
        <member name="M:ORTS.DynatrackDrawer.PrepareFrame(ORTS.RenderFrame,ORTS.ElapsedTime)">
            <summary>
            PrepareFrame adds any object mesh in-FOV to the RenderItemCollection. 
            and marks the last LOD that is in-range.
            </summary>
        </member>
        <member name="M:ORTS.TrProfile.#ctor(MSTS.STFReader)">
            <summary>
            TrProfile constructor from STFReader-style profile file
            </summary>
        </member>
        <member name="M:ORTS.TrProfile.#ctor(System.Xml.XmlReader)">
            <summary>
            TrProfile constructor from XML profile file
            </summary>
        </member>
        <member name="M:ORTS.TrProfile.LODDefineTexture(System.String)">
            <summary>
            LODDefineTexture returns a texture based on the texture identifier string.
            </summary>
        </member>
        <member name="M:ORTS.TrProfile.LODDefaultTexture">
            <summary>
            LODDefaultTexture returns the texture used by the last LOD unless this is the first LOD,
            in which case it returns Image1. 
            </summary>
        </member>
        <member name="M:ORTS.TrProfile.#ctor">
            <summary>
            TrProfile constructor (default - builds from self-contained data)
            </summary>
        </member>
        <member name="M:ORTS.LODItem.#ctor(System.String)">
            <summary>
            LODITem constructor (default &amp; XML)
            </summary>
        </member>
        <member name="M:ORTS.LODItem.#ctor(MSTS.STFReader,ORTS.TrProfile)">
            <summary>
            LODITem constructor (DAT)
            </summary>
        </member>
        <member name="M:ORTS.Polyline.#ctor">
            <summary>
            Bare-bones Polyline constructor (used for XML)
            </summary>
        </member>
        <member name="M:ORTS.Polyline.#ctor(ORTS.TrProfile,System.String,System.UInt32)">
            <summary>
            Polyline constructor (default)
            </summary>
        </member>
        <member name="M:ORTS.Polyline.#ctor(MSTS.STFReader)">
            <summary>
            Polyline constructor (DAT)
            </summary>
        </member>
        <member name="M:ORTS.DynatrackMesh.#ctor(ORTS.RenderProcess,MSTS.DyntrackObj,ORTS.WorldPosition,ORTS.WorldPosition)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:ORTS.DynatrackMesh.BuildMesh(ORTS.WorldPosition)">
            <summary>
            Builds a section of Dynatrack to TrProfile specifications as one vertex buffer and one index buffer.
            The order the buffers are built in reflects the nesting in the TrProfile.  The nesting order is:
            (LOD items (Polylines (Vertices))).  All vertices and indices are built contiguously for an LOD.
            </summary>
        </member>
        <member name="M:ORTS.DynatrackMesh.LinearGen">
            <summary>
            Initializes member variables for straight track sections.
            </summary>
        </member>
        <member name="M:ORTS.DynatrackMesh.CircArcGen">
            <summary>
            Initializes member variables for circular arc track sections.
            </summary>
        </member>
        <member name="M:ORTS.DynatrackMesh.LinearGen(System.UInt32,ORTS.Polyline)">
            <summary>
            Generates vertices for a succeeding cross section (straight track).
            </summary>
            <param name="stride">Index increment between section-to-section vertices.</param>
            <param name="pl"></param>
        </member>
        <member name="M:ORTS.DynatrackMesh.CircArcGen(System.UInt32,ORTS.Polyline)">
            <summary>
            /// Generates vertices for a succeeding cross section (circular arc track).
            </summary>
            <param name="stride">Index increment between section-to-section vertices.</param>
            <param name="pl"></param>
        </member>
        <member name="M:ORTS.DynatrackMesh.InitializeVertexBuffers(Microsoft.Xna.Framework.Graphics.GraphicsDevice)">
            <summary>
            Initializes the vertex and triangle index list buffers.
            </summary>
        </member>
        <member name="M:ORTS.WorldLatLon.ConvertWTC(System.Int32,System.Int32,Microsoft.Xna.Framework.Vector3,System.Double@,System.Double@)">
            <summary>
            Entry point to this series of methods
            Gets Longitude, Latitude from Goode X, Y
            </summary>        
        </member>
        <member name="M:ORTS.WorldLatLon.GoodeInit">
            <summary>
            Initialize the Goode coefficient arrays
            </summary>        
        </member>
        <member name="M:ORTS.WorldLatLon.Goode_Inverse(System.Double,System.Double,System.Double@,System.Double@)">
            <summary>
            Convert Goode XY coordinates to latitude and longitude
            </summary>        
        </member>
        <member name="M:ORTS.WorldLatLon.Sign(System.Double)">
            <summary>
            Returns the sign of a value
            </summary>        
        </member>
        <member name="M:ORTS.WorldLatLon.Adjust_Lon(System.Double)">
            <summary>
            Checks for Pi overshoot
            </summary>        
        </member>
        <member name="T:MSTS.TDBFile">
            <summary>
            Summary description for TDBFile.
            </summary>
            
        </member>
        <member name="M:MSTS.TDBFile.GetTrJunctionNode(System.Int32,System.Int32,System.Int32)">
            <summary>
            Provide a link to the TrJunctionNode for the switch track with 
            the specified UiD on the specified tile.
            
            Called by switch track shapes to determine the correct position of the points.
            </summary>
            <param name="tileX"></param>
            <param name="tileZ"></param>
            <param name="UiD"></param>
            <returns></returns>
        </member>
        <member name="F:MSTS.TrackNode.TrEndNode">
            <summary>
            True when this TrackNode has nothing else connected to it (that is, it is
            a buffer end or an unfinished track) and trains cannot proceed beyond here.
            </summary>
        </member>
        <member name="T:MSTS.SRVFile">
            <summary>
            Work with Service Files
            </summary>
        </member>
        <member name="M:MSTS.SRVFile.#ctor(System.String)">
            <summary>
            Open a service file, 
            filePath includes full path and extension
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:MSTS.SignalType.def_draw_state(ORTS.SignalHead.SIGASP)">
            <summary>
            This method returns the default draw state for the specified aspect or -1 if none.
            </summary>
        </member>
        <member name="M:MSTS.SignalType.GetNextLeastRestrictiveState(ORTS.SignalHead.SIGASP)">
            <summary>
            This method returns the next least restrictive aspect from the one specified.
            </summary>
        </member>
        <member name="M:MSTS.SignalType.GetMostRestrictiveAspect">
            <summary>
            This method returns the most restrictive aspect for this signal type.
            </summary>
        </member>
        <member name="T:ORTS.TDBTravellerDistanceCalculatorHelper">
            <summary>
            Helper class to calculate distances along the path
            </summary>
        </member>
        <member name="M:ORTS.ActivityTaskPassengerStopAt.IsAtStation">
            <summary>
            Determines if the train is at station
            </summary>
            <returns></returns>
        </member>
        <member name="T:ORTS.ThreadNameAttribute">
            <summary>
            Explicitly sets the name of the thread on which the target will run.
            </summary>
        </member>
        <member name="T:ORTS.CallOnThreadAttribute">
            <summary>
            Defines a thread on which the target is allowed to run; multiple threads may be allowed for a single target.
            </summary>
        </member>
        <member name="T:MSTS.CONFile">
            <summary>
            Work with consist files
            </summary>
        </member>
        <member name="T:MSTS.ACTFile">
            <summary>
            Summary description for Class1.
            </summary>
        </member>
        <member name="M:MSTS.EventCategoryLocation.#ctor(System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Create a new 'ActivitySuccess' LocationEvent
            </summary>
        </member>
        <member name="M:MSTS.EventCategoryAction.#ctor(System.Int32)">
            <summary>
            Build a default EventTypeAllStops event
            </summary>
        </member>
        <member name="M:ORTS.WaterTile.PrepareFrame(ORTS.RenderFrame)">
            <summary>
            This is called when the game should draw itself.
            </summary>
        </member>
        <member name="M:ORTS.WaterTile.Draw(Microsoft.Xna.Framework.Graphics.GraphicsDevice)">
            <summary>
            This is called when the water should draw itself.
            </summary>
        </member>
        <member name="T:ORTS.InfoDisplay">
            <summary>
            Displays Viewer frame rate and Viewer.Text debug messages in the upper left corner of the screen.
            </summary>
        </member>
        <member name="M:ORTS.InfoDisplay.PrepareFrame(ORTS.RenderFrame,ORTS.ElapsedTime)">
            <summary>
            Allows the game component to update itself.
            </summary>
        </member>
        <member name="M:ORTS.TextPrimitive.Draw(Microsoft.Xna.Framework.Graphics.GraphicsDevice)">
            <summary>
            This is called when the game should draw itself.
            </summary>
        </member>
        <member name="M:ORTS.TerrainDrawer.LoadPrep">
            <summary>
            Called 10 times per second when its safe to read volatile data
            from the simulator and viewer classes in preparation
            for the Load call.  Copy data to local storage for use 
            in the next load call.
            Executes in the UpdaterProcess thread.
            </summary>
        </member>
        <member name="M:ORTS.TerrainDrawer.Load(ORTS.RenderProcess)">
            <summary>
            Called 10 times a second to load graphics content
            that comes and goes as the player and trains move.
            Called from background LoaderProcess Thread
            Do not access volatile data from the simulator 
            and viewer classes during the Load call ( see
            LoadPrep() )
            Executes in the LoaderProcess thread.
            </summary>
        </member>
        <member name="M:ORTS.TerrainDrawer.LoadAt(System.Int32,System.Int32)">
            <summary>
            If the specified tile isn't already loaded, then
            load it into any available location in the 
            TerrainTiles array.
            </summary>
            <param name="tileX"></param>
            <param name="tileZ"></param>
        </member>
        <member name="M:ORTS.TerrainPatch.Draw(Microsoft.Xna.Framework.Graphics.GraphicsDevice)">
            <summary>
            This is called when the game should draw itself.
            </summary>
        </member>
        <member name="M:ORTS.TerrainPatch.Elevation(System.Int32,System.Int32)">
            <summary>
            Return the terrain elevation in meters above sea level 
            from the specified vertex indices
            x = 0 to 255 from w to e
            z = 0 to 255 from n to s 
            </summary>
            <param name="x"></param>
            <param name="z"></param>
            <returns></returns>
        </member>
        <member name="M:ORTS.TerrainPatch.SpecificTerrainNormal(System.Int32,System.Int32)">
            <summary>
            Return the vertex normal at the specified 
            terrain vertex indices
            x = 0 to 255 from w to e
            z = 0 to 255 from n to s 
            </summary>
            <param name="x"></param>
            <param name="z"></param>
            <returns></returns>
        </member>
        <member name="T:ORTS.SceneryDrawer">
            <summary>
            Handles loading and unloading of WFiles as the viewer moves across the route.
            </summary>
            Maintains an array of the loaded WorldFiles.  As the camera moves, Update
            scans the array, removing WorldFiles that are out of range, and creating new
            WorldFile objects for WFiles that come into range.
        </member>
        <member name="M:ORTS.SceneryDrawer.#ctor(ORTS.Viewer3D)">
            <summary>
            Scenery objects will be loaded into this viewer.
            </summary>
        </member>
        <member name="M:ORTS.SceneryDrawer.LoadPrep">
            <summary>
            Called 10 times per second when its safe to read volatile data
            from the simulator and viewer classes in preparation
            for the Load call.  Copy data to local storage for use 
            in the next load call.
            Executes in the UpdaterProcess thread.
            </summary>
        </member>
        <member name="M:ORTS.SceneryDrawer.Load(ORTS.RenderProcess)">
            <summary>
            Called 10 times a second to load graphics content
            that comes and goes as the player and trains move.
            Called from background LoaderProcess Thread
            Do not access volatile data from the simulator 
            and viewer classes during the Load call ( see
            LoadPrep() )
            Executes in the LoaderProcess thread.
            </summary>
        </member>
        <member name="M:ORTS.SceneryDrawer.LoadAt(System.Int32,System.Int32)">
            <summary>
            If the specified wFile isn't already loaded, then
            load it into any available location in the 
            WorldFiles array.
            </summary>
        </member>
        <member name="T:ORTS.WorldFile">
            <summary>
            Represents a loaded WFile.
            </summary>
        </member>
        <member name="M:ORTS.WorldFile.#ctor(ORTS.Viewer3D,System.Int32,System.Int32)">
            <summary>
            Open the specified WFile and load all the scenery objects into the viewer.
            If the file doesn't exist, then return an empty WorldFile object.
            </summary>
        </member>
        <member name="M:ORTS.WorldFile.WorldPositionFromMSTSLocation(System.Int32,System.Int32,MSTS.STFPositionItem,MSTS.STFQDirectionItem)">
            <summary>
            MSTS WFiles represent some location with a position, quaternion and tile coordinates
            This converts it to the ORTS WorldPosition representation
            </summary>
        </member>
        <member name="M:ORTS.WorldFile.WorldPositionFromMSTSLocation(System.Int32,System.Int32,MSTS.STFPositionItem,MSTS.Matrix3x3)">
            <summary>
            MSTS WFiles represent some location with a position, 3x3 matrix and tile coordinates
            This converts it to the ORTS WorldPosition representation
            </summary>
        </member>
        <member name="M:ORTS.WorldFile.Dispose">
            <summary>
            Unload the scenery objects related to this WFile.
            </summary>
        </member>
        <member name="M:ORTS.WorldFile.WorldFileNameFromTileCoordinates(System.Int32,System.Int32)">
            <summary>
            Build a w filename from tile X and Z coordinates.
            Returns a string eg "w-011283+014482.w"
            </summary>
        </member>
        <member name="M:ORTS.WorldFile.FormatTileCoordinate(System.Int32)">
            <summary>
            For building a filename from tile X and Z coordinates.
            Returns the string representation of a coordinate
            eg "+014482"
            </summary>
        </member>
        <member name="T:ORTS.Interlocking.MovementAuthority.Route">
            <summary>
            Defines a single path between either  a signal
            and a termination object (another signal or a buffer). 
            </summary>
        </member>
        <member name="P:ORTS.Interlocking.MovementAuthority.Route.StartSignal">
            <summary>
            The signal defining the beginning of the route.
            </summary>
        </member>
        <member name="T:ORTS.Interlocking.InterlockingItem">
            <summary>
            Defines the base class for interlocking objects.
            </summary>
        </member>
        <member name="F:ORTS.Interlocking.InterlockingItem.simulator">
            <summary>
            Reference to the simulator object.
            </summary>
        </member>
        <member name="M:ORTS.AI.#ctor(ORTS.Simulator)">
            <summary>
            Loads AI train information from activity file.
            Creates a queue of AI trains in the order they should appear.
            At the moment AI trains are also created off scene so the rendering code will know about them.
            </summary>
        </member>
        <member name="M:ORTS.AI.Update(System.Single)">
            <summary>
            Updates AI train information.
            Creates any AI trains that are scheduled to appear.
            Moves all active AI trains by calling their Update method.
            And finally, removes any AI trains that have reached the end of their path.
            </summary>
        </member>
        <member name="M:ORTS.AI.CreateAITrain(MSTS.Service_Definition)">
            <summary>
            Creates an AI train
            Moves the models down 1000M to make them invisible.
            </summary>
        </member>
        <member name="M:ORTS.AI.RemoveTrains">
            <summary>
            Removes AI trains that have reached the end of their path or
            have been coupled onto by the player train.
            Moves the models down 1000M to make them invisible.
            </summary>
        </member>
        <member name="T:ORTS.UserInput">
            <summary>
            This class adds ability to detect a key click ( press and release )
            to the basic XNA keyboard handling functionality.
            And forms the starting point for a customizable input scenario
            where keyboard and mouse input is converted to symbolic commands and
            its these commands that the viewer class responds to.
            NOTE - I found the keyboard could only be read in the XNA Game Loop (RenderProcess) thread.
            </summary>
        </member>
        <member name="T:ORTS.Interlocking.InterlockingTerminator">
            <summary>
            Defines an object that can be the start or end of route.
            </summary>
        </member>
        <member name="M:ORTS.Interlocking.InterlockingTerminator.#ctor(ORTS.Simulator)">
            <summary>
            Creates a new InterlockingTerminator.
            </summary>
            <param name="simulator"></param>
        </member>
        <member name="M:ORTS.Materials.Initialize(ORTS.RenderProcess)">
            <summary>
            THREAD SAFETY:  XNA Content Manager is not thread safe and must only be called from the Game thread.
            ( per Shawn Hargreaves )
            </summary>
            <param name="renderProcess"></param>
        </member>
        <member name="M:ORTS.SkyMaterial.FogDay2Night(System.Single,System.Single)">
            <summary>
            This function darkens the fog color as night begins to fall
            as well as with increasing overcast.
            </summary>
            <param name="sunHeight">The Y value of the sunlight vector</param>
            <param name="overcast">The amount of overcast</param>
        </member>
        <member name="T:ORTS.YellowMaterial">
            <summary>
            This material is used for debug and testing.
            </summary>
        </member>
        <member name="T:ORTS.MSTSNotchController">
            This is the most used contorller. The main use if for diesel locomotives Throttle control.
            
            It is used with single keypress, this means that when the user press a key, only the keydown event is handled.
            The user need to press the key multiple times to update this controller.
            
        </member>
        <member name="T:ORTS.IController">
            This interface is used to specify how controls will work.
            
            We have a class for implementing each type of controller that locomotives use, being the commons
            the Notched and not Notched controller.          
            
        </member>
        <member name="M:ORTS.MSTSNotchController.SetRDPercent(System.Single)">
            <summary>
            Sets the controller value based on a RailDriver control
            </summary>
            <param name="percent"></param>
        </member>
        <member name="F:ORTS.Train.simulator">
            <summary>
            Reference to the Simulator object.
            </summary>
        </member>
        <member name="M:ORTS.Train.SignalEvent(ORTS.EventID)">
            <summary>
            Someone is sending an event notification to all cars on this train.
            ie doors open, pantograph up, lights on etc.
            </summary>
        </member>
        <member name="M:ORTS.Train.IsEndOfRoute(ORTS.Direction)">
            <summary>
            Returns true if (forward == 1) and front of train on TrEndNode
            or if (forward == 0) and rear of train on TrEndNode.
            </summary>
        </member>
        <member name="M:ORTS.Train.Stop">
            <summary>
            Stops the train ASAP
            </summary>
        </member>
        <member name="M:ORTS.Train.RepositionRearTraveller">
            <summary>
            Cars have been added to the rear of the train, recalc the rearTDBtraveller
            </summary>
        </member>
        <member name="M:ORTS.Train.CalculatePositionOfCars(System.Single)">
            <summary>
            Distance is the signed distance the cars are moving.
            </summary>
            <param name="distance"></param>
        </member>
        <member name="M:ORTS.Train.UpdateTrackOccupation">
            <summary>
            Traverse the cars, occupying tracks underneath.
            </summary>
        </member>
        <member name="M:ORTS.Interlocking.MovementAuthority.RouteCollection.#ctor(ORTS.Interlocking.InterlockingSystem)">
            <summary>
            Creates a new collection of routes.
            </summary>
            <param name="interlockingSystem">The InterlockingSystem object from which
            to create routes.</param>
        </member>
        <member name="M:ORTS.Interlocking.MovementAuthority.RouteCollection.AddRange(System.Collections.Generic.List{ORTS.Interlocking.MovementAuthority.Route})">
            <summary>
            Adds a list of routes to the collection.
            </summary>
            <param name="items">The routes to add to the collection.</param>
        </member>
        <member name="M:ORTS.Interlocking.MovementAuthority.RouteCollection.Add(ORTS.Interlocking.MovementAuthority.Route)">
            <summary>
            Adds a route to the collection.
            </summary>
            <param name="route">The route to add to the collection.</param>
        </member>
        <member name="M:ORTS.Interlocking.MovementAuthority.RouteCollection.FindExistingRoutes(ORTS.Interlocking.InterlockingSignal)">
            <summary>
            Returns all routes beginning with the given signal.
            </summary>
            <param name="StartSignal"></param>
            <returns></returns>
        </member>
        <member name="M:ORTS.Interlocking.MovementAuthority.RouteCollection.FindExistingRoutes(ORTS.Interlocking.InterlockingSignal,ORTS.Interlocking.InterlockingTerminator)">
            <summary>
            Returns all routees starting with the given signal and ending with the given terminator.
            </summary>
            <param name="StartSignal"></param>
            <param name="Terminator"></param>
            <returns></returns>
        </member>
        <member name="M:ORTS.ORTSMath.AlmostEqual(System.Single,System.Single,System.Single)">
            <summary>
            Returns true when the floating point value is *close to* the given value,
            within a given tolerance.
            </summary>
            <param name="thisValue"></param>
            <param name="value">The value to compare with.</param>
            <param name="tolerance">The amount the two values may differ while still being considered equal</param>
            <returns></returns>
        </member>
        <member name="T:ORTS.Interpolator">
            <summary>
            Interpolated table lookup
            Supports linear or cubic spline interpolation
            </summary>
        </member>
        <member name="T:ORTS.Interpolator2D">
            <summary>
            two dimensional Interpolated table lookup
            </summary>
        </member>
        <member name="T:ORTS.Common.BrakeCurves">
            <summary>
            Helper class for computing brake curves for use with train control systems. 
            </summary>
        </member>
        <member name="M:ORTS.Common.BrakeCurves.ComputeCurve(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Given a train's current speed, the distance to a target, and the maximum allowed speed at that target, 
            as well as a desired deceleration value, return the speed the train *should* be travelling in order to
            "follow" the brake curve to the target.
            </summary>
            <param name="currentSpeed">Speed of the vehicle, in m/s.</param>
            <param name="targetDistance">Distance to the target, in metres.</param>
            <param name="targetSpeed">Maximum allowed speed at the target, in m/s.</param>
            <param name="nominalDeceleration">The desired/expected deceleration, in m/s². This must be larger than 0.</param>
            <returns></returns>
        </member>
        <member name="M:ORTS.Heap`1.GetMinKey">
            <summary>
            Returns the smallest key in the heap.
            </summary>
        </member>
        <member name="M:ORTS.Heap`1.GetMinValue">
            <summary>
            Returns the value that corresponds to the smallest key.
            </summary>
        </member>
        <member name="M:ORTS.Heap`1.Add(System.Double,`0)">
            <summary>
            Adds a new heap entry with the given key and value.
            The entry is added to the end of the list and then sifted up.
            </summary>
        </member>
        <member name="M:ORTS.Heap`1.DeleteMin">
            <summary>
            Removes the entry with the smallest key value and returns it.
            The last entry is moved to the front and then sifted down.
            </summary>
        </member>
        <member name="F:MSTS.TileNameConversion.wt_ew_min">
            The following code was derived from MSTSConverter
            Written by: West L. Card
            which was derived from code by  John Stanford 
            //////////////////////////////////////////////
        </member>
        <member name="M:MSTS.TileNameConversion.ComputeTileNameFromTileXZ(System.Int32,System.Int32)">
            <summary>
            ie Returns "-04e9a288"
            </summary>
            <param name="wt_ew"></param>
            <param name="wt_ns"></param>
            <returns></returns>
        </member>
        <member name="T:ORTS.RenderProcess">
            <summary>
            This is the main type for your game
            </summary>
        </member>
        <member name="M:ORTS.RenderProcess.Initialize">
            <summary>
            Allows the game to perform any initialization it needs after the graphics device has started
            </summary>
        </member>
        <member name="M:ORTS.RenderProcess.Update(Microsoft.Xna.Framework.GameTime)">
            <summary>
            Called regularly.   Used to update the simulator class when
            the window is minimized.
            </summary>
        </member>
        <member name="F:ORTS.RenderProcess.ProfileFrames">
            <summary>
            This is called once per frame when the game should draw itself.
            In a multiprocessor environement, it starts the background UpdateProcessor
            task preparing the next frame, while it renders this frame.
            In a single processor environment, it does the update/draw in
            sequence using this thread alone.
            </summary>
        </member>
        <member name="M:ORTS.RenderProcess.Stop">
            <summary>
            This signal is caught in the Update
            </summary>
        </member>
        <member name="M:ORTS.RenderProcess.Terminate">
            <summary>
            Shut down other processes and unload content
            </summary>
        </member>
        <member name="M:ORTS.RenderProcess.OnExiting(System.Object,System.EventArgs)">
            <summary>
            User closed the window without pressing the exit key
            </summary>
        </member>
        <member name="T:ORTS.RailDriverHandler">
            <summary>
            Class to get data from RailDriver and translate it into something useful for UserInput
            </summary>
        </member>
        <member name="M:ORTS.RailDriverHandler.#ctor(System.String)">
            <summary>
            Tries to find a RailDriver and initialize it
            </summary>
            <param name="basePath"></param>
        </member>
        <member name="M:ORTS.RailDriverHandler.HandlePIEHidData(System.Byte[],PIEHidDotNet.PIEDevice)">
            <summary>
            Data callback, called when RailDriver data is available
            </summary>
            <param name="data"></param>
            <param name="sourceDevice"></param>
        </member>
        <member name="M:ORTS.RailDriverHandler.HandlePIEHidError(System.Int32,PIEHidDotNet.PIEDevice)">
            <summary>
            Error callback
            </summary>
            <param name="error"></param>
            <param name="sourceDevice"></param>
        </member>
        <member name="M:ORTS.RailDriverHandler.SetLEDs(System.Byte,System.Byte,System.Byte)">
            <summary>
            Set the RailDriver LEDs to the specified values
            led1 is the right most
            </summary>
            <param name="led1"></param>
            <param name="led2"></param>
            <param name="led3"></param>
        </member>
        <member name="M:ORTS.RailDriverHandler.EnableSpeaker(System.Boolean)">
            <summary>
            Turns raildriver speaker on or off
            </summary>
            <param name="on"></param>
        </member>
        <member name="M:ORTS.RailDriverHandler.Update(ORTS.TrainCar)">
            <summary>
            Updates speed display on RailDriver LED
            </summary>
            <param name="playerLoco"></param>
        </member>
        <member name="M:ORTS.RailDriverHandler.ReadCalibrationData(System.String)">
            <summary>
            Reads RailDriver calibration data from a ModernCalibration.rdm file
            This file is not in the usual STF format, but the STFReader can handle it okay.
            </summary>
            <param name="basePath"></param>
        </member>
        <member name="T:ORTS.RailDriverState">
            <summary>
            Processed RailDriver data sent to UserInput class
            </summary>
        </member>
        <member name="M:ORTS.RailDriverState.SaveButtonData">
            <summary>
            Saves the latest button data and prepares to get new data
            </summary>
        </member>
        <member name="M:ORTS.RailDriverState.AddButtonData(System.Byte[])">
            <summary>
            Ors in new button data
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:ORTS.MSTSElectricLocomotive">
            <summary>
            Adds pantograph control to the basic LocomotiveSimulator functionality
            </summary>
        </member>
        <member name="M:ORTS.MSTSElectricLocomotive.Parse(System.String,MSTS.STFReader)">
            <summary>
            Parse the wag file parameters required for the simulator and viewer classes
            </summary>
        </member>
        <member name="M:ORTS.MSTSElectricLocomotive.InitializeFromCopy(ORTS.MSTSWagon)">
            <summary>
            This initializer is called when we are making a new copy of a car already
            loaded in memory.  We use this one to speed up loading by eliminating the
            need to parse the wag file multiple times.
            NOTE:  you must initialize all the same variables as you parsed above
            </summary>
        </member>
        <member name="M:ORTS.MSTSElectricLocomotive.Save(System.IO.BinaryWriter)">
            <summary>
            We are saving the game.  Save anything that we'll need to restore the 
            status later.
            </summary>
        </member>
        <member name="M:ORTS.MSTSElectricLocomotive.Restore(System.IO.BinaryReader)">
            <summary>
            We are restoring a saved game.  The TrainCar class has already
            been initialized.   Restore the game state.
            </summary>
        </member>
        <member name="M:ORTS.MSTSElectricLocomotive.GetViewer(ORTS.Viewer3D)">
            <summary>
            Create a viewer for this locomotive.   Viewers are only attached
            while the locomotive is in viewing range.
            </summary>
        </member>
        <member name="M:ORTS.MSTSElectricLocomotive.Update(System.Single)">
            <summary>
            This is a periodic update to calculate physics 
            parameters and update the base class's MotiveForceN 
            and FrictionForceN values based on throttle settings
            etc for the locomotive.
            </summary>
        </member>
        <member name="M:ORTS.MSTSElectricLocomotive.SignalEvent(ORTS.EventID)">
            <summary>
            Used when someone want to notify us of an event
            </summary>
        </member>
        <member name="T:ORTS.MSTSElectricLocomotiveViewer">
            <summary>
            Adds pantograph animation to the basic LocomotiveViewer class
            </summary>
        </member>
        <member name="M:ORTS.MSTSElectricLocomotiveViewer.HandleUserInput(ORTS.ElapsedTime)">
            <summary>
            A keyboard or mouse click has occured. Read the UserInput
            structure to determine what was pressed.
            </summary>
        </member>
        <member name="M:ORTS.MSTSElectricLocomotiveViewer.PrepareFrame(ORTS.RenderFrame,ORTS.ElapsedTime)">
            <summary>
            We are about to display a video frame.  Calculate positions for 
            animated objects, and add their primitives to the RenderFrame list.
            </summary>
        </member>
        <member name="M:ORTS.MSTSElectricLocomotiveViewer.Unload">
            <summary>
            This doesn't function yet.
            </summary>
        </member>
        <member name="M:ORTS.SoundProcess.#ctor(ORTS.Viewer3D)">
            <summary>
            Constructs SoundProcess, creates the sound thread but not start. Must create after loading ingame sounds.
            </summary>
        </member>
        <member name="M:ORTS.SoundProcess.Run">
            <summary>
            Checks the SoundDetail level, and if above 0, starts sound thread.
            </summary>
        </member>
        <member name="M:ORTS.SoundProcess.Stop">
            <summary>
            Stops sound thread
            </summary>
        </member>
        <member name="M:ORTS.SoundProcess.AddSoundSource(System.Object,System.Collections.Generic.List{ORTS.SoundSource})">
            <summary>
            Adds a SoundSource list attached to an object to the playable sounds.
            </summary>
            <param name="viewer">The viewer object, could be anything</param>
            <param name="sources">List of SoundSources to play</param>
        </member>
        <member name="M:ORTS.SoundProcess.RemoveSoundSource(System.Object)">
            <summary>
            Removes a SoundSource list attached to an object from the playable sounds.
            </summary>
            <param name="viewer">The viewer object the sounds attached to</param>
        </member>
        <member name="M:ORTS.SoundProcess.SoundUpdateLoop">
            <summary>
            The loop running in the thread
            </summary>
        </member>
        <member name="M:ORTS.Dispatcher.#ctor(ORTS.AI)">
            <summary>
            Initializes the dispatcher.
            Creates an array for saving track node reservations and initializes it to no reservations.
            </summary>
        </member>
        <member name="M:ORTS.Dispatcher.Update(System.Double,System.Single)">
            <summary>
            Updates dispatcher information.
            Moves each train's rear path node forward and updates reservations.
            </summary>
        </member>
        <member name="M:ORTS.Dispatcher.RequestAuth(ORTS.AITrain,System.Boolean)">
            <summary>
            Requests movement authorization for the specified train.
            Follows the train's path from the current rear node until the path ends
            or a SidingEnd node is found.  Grants authorization if all of the track
            vector nodes can be reserved for the train.
            If a SidingStart node is found, the main track and siding are tested separately.
            Returns true if an authorization was granted, else false.
            The authorization is specified using the SetAuthorization method.
            </summary>
        </member>
        <member name="M:ORTS.Dispatcher.SetAuthorization(ORTS.TrackAuthority,ORTS.AIPathNode,ORTS.AIPathNode,System.Int32)">
            <summary>
            end is the path node the train is allowed to move just short of.
            if siding is not null the train should enter the siding at the specified node.
            The dispatcher might change the authorization while a train is moving.
            </summary>
        </member>
        <member name="M:ORTS.Dispatcher.CanReserve(System.Int32,System.Int32,System.Collections.Generic.List{System.Int32})">
            <summary>
            Checks to see is the listed track nodes can be reserved for the specified train.
            return true if none of the nodes are already reserved for another train.
            </summary>
        </member>
        <member name="M:ORTS.Dispatcher.Reserve(System.Int32,System.Collections.Generic.List{System.Int32})">
            <summary>
            Reserves the listed track nodes for the specified train.
            </summary>
        </member>
        <member name="M:ORTS.Dispatcher.Unreserve(System.Int32)">
            <summary>
            Clears any existing Reservations for the specified train.
            </summary>
        </member>
        <member name="M:ORTS.Dispatcher.Release(ORTS.AITrain)">
            <summary>
            Releases the specified train's movement authorization.
            </summary>
        </member>
        <member name="M:ORTS.Dispatcher.Rereserve(ORTS.TrackAuthority)">
            <summary>
            Releases the specified train's movement authorization.
            </summary>
        </member>
        <member name="M:ORTS.Dispatcher.FindDoubleTrack">
            <summary>
            Scans all AI paths to identify double track passing possibilities.
            Changes the path node type to SidingEnd if its the end of double track.
            </summary>
        </member>
        <member name="M:ORTS.Dispatcher.CalcTrackLength">
            <summary>
            Calculates the length of all track vector nodes and saves it in the TrackLength array.
            This should probably be moved elsewhere if others need this information.
            </summary>
        </member>
        <member name="M:MSTS.TWorldDirection.RotatePoint(MSTS.TWorldPosition)">
            <summary>
            Rotate the specified point in model space to a new location according to the quaternion 
            Center of rotation is 0,0,0 in model space
            Example   xyz = 0,1,2 rotated 90 degrees east becomes 2,1,0
            </summary>
            <param name="p1"></param>
        </member>
        <member name="T:ORTS.WireDrawer">
            <summary>
            Created by a Viewer
            </summary>
        </member>
        <member name="M:ORTS.WireDrawer.#ctor(ORTS.Viewer3D)">
            <summary>
            Called once after the graphics device is ready
            to load any static graphics content, background 
            processes haven't started yet.
            Executes in the RenderProcess thread.
            </summary>
        </member>
        <member name="M:ORTS.WireDrawer.LoadPrep">
            <summary>
            Called 10 times per second when its safe to read volatile data
            from the simulator and viewer classes in preparation
            for the Load call.  Copy data to local storage for use 
            in the next load call.
            Executes in the UpdaterProcess thread.
            </summary>
        </member>
        <member name="M:ORTS.WireDrawer.Load(ORTS.RenderProcess)">
            <summary>
            Called 10 times a second to load graphics content
            that comes and goes as the player and trains move.
            Called from background LoaderProcess Thread
            Do not access volatile data from the simulator 
            and viewer classes during the Load call ( see
            LoadPrep() )
            Executes in the LoaderProcess thread.
            Do not read volatile data managed by the UpdaterProcess
            </summary>
        </member>
        <member name="M:ORTS.WireDrawer.PrepareFrame(ORTS.RenderFrame,ORTS.ElapsedTime)">
            <summary>
            Called every frame to update animations and load the frame contents .
            Note:  this doesn't actually draw on the screen surface, but 
            instead prepares a list of drawing primitives that will be rendered
            later in RenderFrame.Draw() by the RenderProcess thread.
            elapsedTime represents the the time since the last call to PrepareFrame
            Executes in the UpdaterProcess thread.
            </summary>
        </member>
        <member name="T:ORTS.WireMaterial">
            <summary>
            This encapsulates any shaders, sprites, etc needed by the material.
            </summary>
        </member>
        <member name="M:ORTS.WireMaterial.Render(Microsoft.Xna.Framework.Graphics.GraphicsDevice,System.Collections.Generic.IEnumerable{ORTS.RenderItem},Microsoft.Xna.Framework.Matrix@,Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Called by RenderFrame.Draw() in the RenderProcess thread for each primitive
            that was loaded by PrepareFrame
            </summary>
        </member>
        <member name="M:ORTS.WirePrimitive.Draw(Microsoft.Xna.Framework.Graphics.GraphicsDevice)">
            <summary>
            This is when the object actually renders itself onto the screen.
            Do not reference any volatile data.
            Executes in the RenderProcess thread called from the Render method of the material class
            </summary>
        </member>
        <member name="M:ORTS.MSTSCoupling.Save(System.IO.BinaryWriter)">
            <summary>
            We are saving the game.  Save anything that we'll need to restore the 
            status later.
            </summary>
        </member>
        <member name="M:ORTS.MSTSCoupling.Restore(System.IO.BinaryReader)">
            <summary>
            We are restoring a saved game.  The TrainCar class has already
            been initialized.   Restore the game state.
            </summary>
        </member>
        <member name="T:ORTS.CarManager">
            <summary>
            Utility class to avoid loading the wag file multiple times
            </summary>
        </member>
        <member name="T:ORTS.Interlocking.InterlockingSignal">
            <summary>
            Provides an abstraction atop an underlying signal
            object.
            </summary>
        </member>
        <member name="M:ORTS.Interlocking.InterlockingSignal.#ctor(ORTS.Simulator,ORTS.SignalObject)">
            <summary>
            Creates a new InterlockingSignal object.
            </summary>
            <param name="simulator"></param>
            <param name="signalObject"></param>
        </member>
        <member name="P:ORTS.Interlocking.InterlockingSignal.SignalObject">
            <summary>
            Gets the underlying SignalObject.
            </summary>
        </member>
        <member name="P:ORTS.Interlocking.InterlockingSignal.IsShowingAnyProceed">
            <summary>
            Returns true when any of the signal heads show any "proceed" aspect.
            </summary>
        </member>
        <member name="M:ORTS.SunMoonPos.SolarAngle(System.Double,System.Double,System.Single,ORTS.SkyDrawer.Date)">
            <summary>
            Calculates the solar direction vector.
            Used for locating the sun graphic and as the location of the main scenery light source.
            </summary>
            <param name="latitude">latitude</param>
            <param name="longitude">longitude</param>
            <param name="clockTime">wall clock time since start of activity, days</param>
            <param name="date">structure made up of day, month, year and ordinal date</param>
        </member>
        <member name="M:ORTS.SunMoonPos.LunarAngle(System.Double,System.Double,System.Single,ORTS.SkyDrawer.Date)">
            <summary>
            Calculates the lunar direction vector. 
            </summary>
            <param name="latitude">latitude</param>
            <param name="longitude">longitude</param>
            <param name="clockTime">wall clock time since start of activity</param>
            <param name="date">structure made up of day, month, year and ordinal date</param>
        </member>
        <member name="M:ORTS.SunMoonPos.Normalize(System.Double,System.Double)">
            <summary>
            Removes all multiples of "divisor" from the input number.
            </summary>
            <param name="input">the raw number</param>
            <param name="divisor">the number, or its multiples, we want to remove</param> 
        </member>
        <member name="T:ORTS.WorldPosition">
            <summary>
            Represents the position and orientation of an object
            including what tile, and the matrix within the tile
            </summary>
        </member>
        <member name="M:ORTS.WorldPosition.Normalize">
            <summary>
            Ensure tile coordinates are within tile boundaries
            </summary>
        </member>
        <member name="M:ORTS.WorldLocation.Normalize">
            <summary>
            Ensure tile coordinates are within tile boundaries
            </summary>
        </member>
        <member name="T:MSTS.CAMCFGFile">
            <summary>
            Object used by ORTS.Cameras to set up views (3dviewer\camera.cs)
            </summary>
        </member>
        <member name="T:MSTS.Camera">
            <summary>
            Individual camera object from the config file
            </summary>
        </member>
        <member name="M:ORTS.Program.Main(System.String[])">
            <summary>
            The main entry point for the application.
            </summary>
        </member>
        <member name="M:ORTS.Program.Start(System.Collections.Generic.IEnumerable{System.String},System.String[])">
            <summary>
            Run the specified activity from the beginning.
            </summary>
        </member>
        <member name="M:ORTS.Program.Save">
            <summary>
            Save the current game state for later resume.
            Currently only supports one save, in a SAVE.BIN file in 
            the users local program storage, 
            ie.  "C:\\Users\\Wayne\\AppData\\Roaming\\ORTS\\SAVE.BIN"
            </summary>
        </member>
        <member name="M:ORTS.Program.Resume(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Resume a saved game.
            </summary>
        </member>
        <member name="M:ORTS.Program.IsWarningsOn">
            <summary>
            Check the registry and return true if the OpenRailsLog.TXT
            file should be created.
            </summary>
        </member>
        <member name="M:ORTS.Program.EnableLogging">
            <summary>
            Set up to capture all console and error I/O into a  log file.
            </summary>
        </member>
        <member name="M:ORTS.Program.SetBuildRevision">
            <summary>
            Set up the global Build and Revision variables
            from assembly data and the revision.txt file.
            </summary>
        </member>
        <member name="T:ORTS.Program.Testing">
            <summary>
            This class is for programmer's use in setting up adhoc tests.
            </summary>
        </member>
        <member name="M:ORTS.Program.Testing.GetRandomActivity">
            <summary>
            For testing purposes, select a random activity from the available routes.
            </summary>
        </member>
        <member name="M:ORTS.Program.Testing.Test">
            <summary>
            Adhoc testing for programmers
            </summary>
        </member>
        <member name="M:ORTS.Program.Testing.TestAll">
            <summary>
            Test all files in all MSTS folders 
            used by the development team for adhoc testing - customize this for whatever you need
            </summary>
        </member>
        <member name="M:ORTS.SkyDrawer.#ctor(ORTS.Viewer3D)">
            <summary>
            SkyDrawer constructor
            </summary>
        </member>
        <member name="M:ORTS.SkyDrawer.PrepareFrame(ORTS.RenderFrame,ORTS.ElapsedTime)">
            <summary>
            Used to update information affecting the SkyMesh
            </summary>
        </member>
        <member name="M:ORTS.SkyMesh.#ctor(ORTS.RenderProcess)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:ORTS.SkyMesh.DomeVertexList(System.Int32,System.Int32,System.Single)">
            <summary>
            Creates the vertex list for each sky dome.
            </summary>
            <param name="index">The starting vertex number</param>
            <param name="radius">The radius of the dome</param>
            <param name="oblate">The amount the dome is flattened</param>
        </member>
        <member name="M:ORTS.SkyMesh.DomeTriangleList(System.Int16,System.Int16)">
            <summary>
            Creates the triangle index list for each dome.
            </summary>
            <param name="index">The starting triangle index number</param>
            <param name="pass">A multiplier used to arrive at the starting vertex number</param>
        </member>
        <member name="M:ORTS.SkyMesh.MoonLists(System.Int32,System.Int32)">
            <summary>
            Creates the moon vertex and triangle index lists.
            <param name="vertexIndex">The starting vertex number</param>
            <param name="iIndex">The starting triangle index number</param>
            </summary>
        </member>
        <member name="M:ORTS.SkyMesh.InitializeVertexBuffers(Microsoft.Xna.Framework.Graphics.GraphicsDevice)">
            <summary>
            Initializes the sky dome, cloud dome and moon vertex and triangle index list buffers.
            </summary>
        </member>
        <member name="T:ORTS.ProcessState">
            <summary>
            Provides interprocess signalling.
            Manages a process as finished, or started
            with thread blocking calls to wait for the desired state
            without spin poll wait loops
            </summary>
        </member>
        <member name="M:ORTS.ProcessState.#ctor">
            <summary>
            Initializes a process state object to 
            finished state.
            </summary>
        </member>
        <member name="T:ORTS.Interlocking.InterlockingSystem">
            <summary>
            Encapsulates the interlocking and signalling system.
            </summary>
        </member>
        <member name="F:ORTS.Interlocking.InterlockingSystem.simulator">
            <summary>
            Reference to the simulator object.
            </summary>
        </member>
        <member name="M:ORTS.Interlocking.InterlockingSystem.#ctor(ORTS.Simulator)">
            <summary>
            Creates a new InterlockingSystem object.
            </summary>
            <param name="simulator">The simulator from which to create an InterlockingSystem.</param>
        </member>
        <member name="M:ORTS.Interlocking.InterlockingSystem.CreateSwitches">
            <summary>
            Instantiates InterlockingSignal objects from the simulation's SignalObject objects.
            </summary>
        </member>
        <member name="M:ORTS.Interlocking.InterlockingSystem.CreateSignals">
            <summary>
            Instantiates InterlockingSignal objects from the simulation's SignalObject objects.
            </summary>
        </member>
        <member name="M:ORTS.Interlocking.InterlockingSystem.CreateTracks">
            <summary>
            Instantiates InterlockingTrack objects from the simulation's TrVectorSection.
            </summary>
        </member>
        <member name="P:ORTS.Interlocking.InterlockingSystem.Tracks">
            <summary>
            Links the underlying TrackNode to its corresponding interlocking layer counterpart.
            </summary>
        </member>
        <member name="P:ORTS.Interlocking.InterlockingSystem.Signals">
            <summary>
            Links the underlying TrVectorSection to its corresponding interlocking layer counterpart.
            </summary>
        </member>
        <member name="P:ORTS.Interlocking.InterlockingSystem.Switches">
            <summary>
            Links the underlying Switch to its corresponding interlocking layer counterpart.
            </summary>
        </member>
        <member name="P:ORTS.Interlocking.InterlockingSystem.Buffers">
            <summary>
            Links underlying TrackNode objects representing buffer ends
            </summary>
        </member>
        <member name="P:ORTS.Interlocking.InterlockingSystem.Routes">
            <summary>
            Contains all routes within the interlocking system.
            </summary>
        </member>
        <member name="T:ORTS.Interlocking.AutomaticBlock">
            <summary>
            Defines an automatic block for interlocking purposes.
            </summary>
        </member>
        <member name="M:ORTS.Interlocking.AutomaticBlock.#ctor(System.Collections.Generic.List{ORTS.Interlocking.InterlockingTrack})">
            <summary>
            Creates a new automatic block from a series of tracks.
            </summary>
            <param name="constituentTracks"></param>
        </member>
        <member name="P:ORTS.Interlocking.AutomaticBlock.Tracks">
            <summary>
            Contains references to tracks within the AutomaticBlock.
            </summary>
        </member>
        <member name="P:ORTS.Interlocking.AutomaticBlock.AnyTracksOccupied">
            <summary>
            Returns true if ANY of the tracks in the AutomaticBlock are occupied.
            </summary>
        </member>
        <member name="F:ORTS.Debugging.GenericObjectViewerForm.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:ORTS.Debugging.GenericObjectViewerForm.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:ORTS.Debugging.GenericObjectViewerForm.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:ORTS.Debugging.GenericObjectViewerForm.RefreshView">
            <summary>
            Get the propertyGrid to refresh, if any of the values
            gas changed.
            </summary>
        </member>
        <member name="T:ORTS.SoundSource">
            SOUND SOURCE
        </member>
        <member name="M:ORTS.SoundSource.#ctor(ORTS.Viewer3D,ORTS.MSTSWagon,System.String)">
            <summary>
            Construct a SoundSource attached to a train car.
            </summary>
            <param name="viewer"></param>
            <param name="car"></param>
            <param name="smsFilePath"></param>
        </member>
        <member name="M:ORTS.SoundSource.#ctor(ORTS.Viewer3D,System.String)">
            <summary>
            Initializes a SoundSource which has no specific loaction - like ingame.sms
            </summary>
            <param name="viewer"></param>
            <param name="smsFilePath"></param>
        </member>
        <member name="M:ORTS.SoundSource.#ctor(ORTS.Viewer3D,ORTS.WorldLocation,System.String)">
            <summary>
            Construct a SoundSource stationary at the specified worldLocation
            </summary>
            <param name="viewer"></param>
            <param name="worldLocation"></param>
            <param name="smsFilePath"></param>
        </member>
        <member name="M:ORTS.SoundSource.Uninitialize">
            <summary>
            No need to play the sounds, stop them
            </summary>
        </member>
        <member name="M:ORTS.SoundSource.Activate">
            <summary>
            Return true if activation conditions are met,
            ie PassengerCam, CabCam, Distance etc
            </summary>
            <returns></returns>
        </member>
        <member name="M:ORTS.SoundSource.DeActivate">
            <summary>
            Return true if deactivation conditions are met
            ie PassengerCam, CabCam, Distance etc
            </summary>
            <returns></returns>
        </member>
        <member name="M:ORTS.SoundSource.ConditionsMet(MSTS.Activation)">
            <summary>
            Return true of the ViewPoint matches any of the ones specified in the conditions
            for activation or deactivation.
            </summary>
            <param name="conditions"></param>
            <returns></returns>
        </member>
        <member name="T:ORTS.SoundStream">
            SOUND STREAM
        </member>
        <member name="M:ORTS.SoundStream.Update(IrrKlang.Vector3D)">
            <summary>
            Update frequency and volume relative to curves
            Position is in IRRKLANG space relative to listener
            </summary>
        </member>
        <member name="M:ORTS.SoundStream.SetFreqAndVolume">
            <summary>
            Separated Frequency and Volume calculations to prevent glitches - by GeorgeS
            </summary>
        </member>
        <member name="M:ORTS.SoundStream.Interpolate(System.Single,MSTS.CurvePoint[])">
            <summary>
            There must be at least two points in the curve
            // TODO do we need to implement support for Granularity()
            </summary>
            <param name="x"></param>
            <param name="curvePoints"></param>
            <returns></returns>
        </member>
        <member name="M:ORTS.SoundStream.ReadValue(MSTS.VolumeCurve.Controls,ORTS.MSTSWagon)">
            <summary>
            Read a variable from the car data in the simulator.
            </summary>
            <param name="control"></param>
            <param name="car"></param>
            <returns></returns>
        </member>
        <member name="M:ORTS.SoundStream.StopRepeating">
            <summary>
            Clears (already stopped) sound information - by GeorgeS
            </summary>
        </member>
        <member name="M:ORTS.SoundStream.Activate">
            <summary>
            Restore any previously playing sounds
            </summary>
        </member>
        <member name="M:ORTS.SoundStream.Deactivate">
            <summary>
            Deactivates a previously active sound
            </summary>
        </member>
        <member name="M:ORTS.SoundStream.CheckSoundQueue">
            <summary>
            Check the playable sound queue. If the previous stopped and available a next sound
            it begins to play. Timed solution!
            </summary>
        </member>
        <member name="M:ORTS.SoundStream.Play3D(System.Boolean,IrrKlang.ISoundSource)">
            <summary>
            Play the specified sound 
            at the default volume.
            </summary>
            <param name="repeat"></param>
            <param name="iSoundSource"></param>
        </member>
        <member name="T:ORTS.ORTSTrigger">
            SOUND TRIGGERS
        </member>
        <member name="T:ORTS.ORTSDiscreteTrigger">
            <summary>
            Play this sound when a discrete TrainCar event occurs in the simulator
            </summary>
        </member>
        <member name="T:ORTS.ORTSDistanceTravelledTrigger">
            <summary>
            Play this sound controlled by the distance a TrainCar has travelled
            </summary>
        </member>
        <member name="T:ORTS.ORTSInitialTrigger">
            <summary>
            Play this sound immediately when this SoundSource becomes active
            </summary>
        </member>
        <member name="T:ORTS.ORTSRandomTrigger">
            <summary>
            Play the sound at random times
            </summary>
        </member>
        <member name="T:ORTS.ORTSDistanceTrigger">
            <summary>
            Control sounds based on TrainCar variables in the simulator 
            </summary>
        </member>
        <member name="T:ORTS.ORTSVariableTrigger">
            <summary>
            Control sounds based on TrainCar variables in the simulator 
            </summary>
        </member>
        <member name="T:ORTS.ORTSPlayOneShot">
            <summary>
            Play a sound file once.
            </summary>
        </member>
        <member name="T:ORTS.ORTSSoundPlayCommand">
            <summary>
            A base class for commands that play a sound.
            Provides for selecting the sound from multiple files
            using a random or sequential selection strategy.
            </summary>
        </member>
        <member name="T:ORTS.ORTSSoundCommand">
            <summary>
            A base class for all sound commands
            Defines that they all have a stream and a 'run()' function
            </summary>
        </member>
        <member name="M:ORTS.ORTSSoundCommand.FromMSTS(MSTS.SoundCommand,ORTS.SoundStream)">
            <summary>
            Create a sound command based on the sound command variable in an SMS file.
            </summary>
            <param name="mstsSoundCommand"></param>
            <param name="soundStream"></param>
            <returns></returns>
        </member>
        <member name="T:ORTS.ORTSStartLoop">
            <summary>
            Start a repeating sound
            </summary>
        </member>
        <member name="T:ORTS.ORTSReleaseLoopRelease">
            <summary>
            Stop a repeating sound.
            </summary>
        </member>
        <member name="T:ORTS.ORTSStartLoopRelease">
            <summary>
            Start a looping sound that uses repeat markers
            TODO - until we implement markers, this will start the sound as a simple one shot
            </summary>
        </member>
        <member name="T:ORTS.ORTSReleaseLoopReleaseWithJump">
            <summary>
            Jump to the exit portion of a looping sound with repeat markers   
            </summary>
        </member>
        <member name="T:ORTS.ORTSDisableTrigger">
            <summary>
            Shut down this stream trigger 
            </summary>
        </member>
        <member name="T:ORTS.ORTSEnableTrigger">
            <summary>
            Re-enable this stream trigger
            </summary>
        </member>
        <member name="T:ORTS.ORTSSetStreamVolume">
            <summary>
            Set Volume Command
            </summary>
        </member>
        <member name="T:ORTS.ORTSNoOp">
            <summary>
            Used when the SMS file sound command is missing or malformed
            </summary>
        </member>
        <member name="M:ORTS.WorldSounds.WorldFileNameFromTileCoordinates(System.Int32,System.Int32)">
            <summary>
            Build a w filename from tile X and Z coordinates.
            Returns a string eg "w-011283+014482.w"
            </summary>
        </member>
        <member name="M:ORTS.WorldSounds.FormatTileCoordinate(System.Int32)">
            <summary>
            For building a filename from tile X and Z coordinates.
            Returns the string representation of a coordinate
            eg "+014482"
            </summary>
        </member>
        <member name="M:ORTS.StaticShape.#ctor(ORTS.Viewer3D,System.String,ORTS.WorldPosition,ORTS.ShapeFlags)">
            <summary>
            Construct and initialize the class
            This constructor is for objects described by a MSTS shape file
            </summary>
        </member>
        <member name="T:ORTS.PoseableShape">
            <summary>
            Has a heirarchy of objects that can be moved by adjusting the XNAMatrices
            at each node.
            </summary>
        </member>
        <member name="M:ORTS.PoseableShape.#ctor(ORTS.Viewer3D,System.String,ORTS.WorldPosition,ORTS.ShapeFlags)">
            <summary>
            Construct and initialize the class
            </summary>
        </member>
        <member name="M:ORTS.PoseableShape.AnimateMatrix(System.Int32,System.Single)">
            <summary>
            Adjust the pose of the specified node to the frame position specifed by key.
            </summary>
        </member>
        <member name="T:ORTS.AnimatedShape">
            <summary>
            An animated shape has a continuous repeating motion defined
            in the animations of the shape file.
            </summary>
        </member>
        <member name="M:ORTS.AnimatedShape.#ctor(ORTS.Viewer3D,System.String,ORTS.WorldPosition,ORTS.ShapeFlags)">
            <summary>
            Construct and initialize the class
            </summary>
        </member>
        <member name="T:ORTS.SharedShapeManager">
            <summary>
            Conserves memory by sharing the basic shape data with multiple instances in the scene.
            </summary>
        </member>
        <member name="M:ORTS.ShapePrimitive.Draw(Microsoft.Xna.Framework.Graphics.GraphicsDevice)">
            <summary>
            This is called when the game should draw itself.
            Executes in RenderProcess thread.
            </summary>
        </member>
        <member name="M:ORTS.SharedShape.#ctor(ORTS.Viewer3D)">
            <summary>
            Create an empty shape used as a sub when the shape won't load
            </summary>
            <param name="viewer"></param>
        </member>
        <member name="M:ORTS.SharedShape.#ctor(ORTS.Viewer3D,System.String)">
            <summary>
            MSTS shape from shape file
            </summary>
            <param name="viewer"></param>
            <param name="path">Path to shape's S file</param>
        </member>
        <member name="M:ORTS.SharedShape.LoadContent(System.String)">
            <summary>
            Only one copy of the model is loaded regardless of how many copies are placed in the scene.
            </summary>
        </member>
        <member name="M:ORTS.SharedShape.PrepareFrame(ORTS.RenderFrame,ORTS.WorldPosition,ORTS.ShapeFlags)">
            <summary>
            This is called by the individual instances of the shape when it should draw itself at the specified location
            </summary>
        </member>
        <member name="M:ORTS.SharedShape.PrepareFrame(ORTS.RenderFrame,ORTS.WorldPosition,Microsoft.Xna.Framework.Matrix[],ORTS.ShapeFlags)">
            <summary>
            This is called by the individual instances of the shape when it should draw itself at the specified location
            with individual matrices animated as shown.
            </summary>
        </member>
        <member name="T:ORTS.ExtendedCVF">
            <summary>
            Extended CVF data, currently used for CAB light
            By GeorgeS
            </summary>
        </member>
        <member name="T:ORTS.ExtendedCVF.Light">
            <summary>
            Represents a Light in the CAB.
            </summary>
        </member>
        <member name="F:ORTS.ExtendedCVF.Light.Position">
            <summary>
            X,Y : Position of the light, Z : Radius, W : Aspect ratio X:Y
            </summary>
        </member>
        <member name="M:ORTS.ExtendedCVF.Light.TranslatedPosition(Microsoft.Xna.Framework.Point)">
            <summary>
            Translate to current screen resolution
            </summary>
            <param name="displaySize">Current screen resolution</param>
            <returns>Translated vectors</returns>
        </member>
        <member name="P:ORTS.ExtendedCVF.Light.TranslatedColor">
            <summary>
            Used by the shader
            </summary>
        </member>
        <member name="T:ORTS.CABTextureManager">
            <summary>
            Manages all CAB View textures - light conditions and texture parts
            </summary>
        </member>
        <member name="M:ORTS.CABTextureManager.LoadTextures(ORTS.Viewer3D,System.String)">
            <summary>
            Loads a texture, day night and cablight
            </summary>
            <param name="viewer">Viver3D</param>
            <param name="FileName">Name of the Texture</param>
        </member>
        <member name="M:ORTS.CABTextureManager.Disassemble(Microsoft.Xna.Framework.Graphics.GraphicsDevice,Microsoft.Xna.Framework.Graphics.Texture2D,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Disassembles a compund Texture into parts
            </summary>
            <param name="graphicsDevice">The GraphicsDevice</param>
            <param name="tex">Texture to be disassembled</param>
            <param name="width">Width of the Cab View Control</param>
            <param name="height">Height of the Cab View Control</param>
            <param name="FramesCount">Number of frames read from CVF</param>
            <param name="FileName">Name of the control ACE file</param>
            <returns>Array with Textures disassembled</returns>
        </member>
        <member name="M:ORTS.CABTextureManager.DisassembleTexture(Microsoft.Xna.Framework.Graphics.GraphicsDevice,System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Disassembles all compund textures into parts
            </summary>
            <param name="graphicsDevice">The GraphicsDevice</param>
            <param name="FileName">Name of the Texture to be disassembled</param>
            <param name="width">Width of the Cab View Control</param>
            <param name="height">Height of the Cab View Control</param>
            <param name="FramesCount">Number of frames, read from CVF</param>
        </member>
        <member name="M:ORTS.CABTextureManager.SafeGetAt(Microsoft.Xna.Framework.Graphics.Texture2D[],System.Int32,System.String)">
            <summary>
            Gets a Texture from the given array
            </summary>
            <param name="arr">Texture array</param>
            <param name="indx">Index</param>
            <param name="FileName">Name of the file to report</param>
            <returns>The given Texture</returns>
        </member>
        <member name="M:ORTS.CABTextureManager.GetTextureByIndexes(System.String,System.Int32,System.Boolean,System.Boolean,System.Boolean@)">
            <summary>
            Returns the compound part of a Texture previously disassembled
            </summary>
            <param name="FileName">Name of the disassembled Texture</param>
            <param name="indx">Index of the part</param>
            <param name="isDark">Is dark out there?</param>
            <param name="isLight">Is Cab Light on?</param>
            <param name="isNightTexture"></param>
            <returns>The Texture represented by its index</returns>
        </member>
        <member name="M:ORTS.CABTextureManager.GetTexture(System.String,System.Boolean,System.Boolean,System.Boolean@)">
            <summary>
            Returns a Texture by its name
            </summary>
            <param name="FileName">Name of the Texture</param>
            <param name="isDark">Is dark out there?</param>
            <param name="isLight">Is Cab Light on?</param>
            <param name="isNightTexture"></param>
            <returns>The Texture</returns>
        </member>
        <member name="T:ORTS.CabViewControlRenderer">
            <summary>
            Base class for rendering Cab Controls
            </summary>
        </member>
        <member name="M:ORTS.CabViewControlRenderer.TranslateToPercent">
            <summary>
            Gets the requested Locomotive data and translates it into percents by Min and Max values
            </summary>
            <returns>Percent of real data by Min and Max values</returns>
        </member>
        <member name="T:ORTS.CabViewDialRenderer">
            <summary>
            Dial Cab Control Renderer
            Problems with aspect ratio
            </summary>
        </member>
        <member name="T:ORTS.CabViewGaugeRenderer">
            <summary>
            Gauge type renderer
            Supports pointer, liquid, solid
            Supports Orientation and Direction
            </summary>
        </member>
        <member name="T:ORTS.CabViewDiscreteRenderer">
            <summary>
            Discrete renderer for Lever, Twostate, Tristate, Multistate, Signal
            </summary>
        </member>
        <member name="M:ORTS.CabViewDiscreteRenderer.GetDrawIndex">
            <summary>
            Determines the index of the Texture to be drawn
            </summary>
            <returns>index of the Texture</returns>
        </member>
        <member name="M:ORTS.CabViewDiscreteRenderer.FromPercent(System.Single)">
            <summary>
            Translates a percent value to a display index
            </summary>
            <param name="percent">Percent to be translated</param>
            <returns>The calculated display index by the Control's Values</returns>
        </member>
        <member name="T:ORTS.CabViewDigitalRenderer">
            <summary>
            Digital Cab Control renderer
            Uses fonts instead of graphic
            Do not supports Justification
            </summary>
        </member>
        <member name="T:ORTS.MSTSBrakeController">
            This is the a Controller used to control brakes.
            
            This is mainly a Notch controller, but it allows continuos input and also 
            has specific methods update brake status.
            
        </member>
        <member name="T:ORTS.IBrakeController">
            This is the interface for a controller that can be used as a BrakeController.
            
        </member>
        <member name="T:ORTS.Popups.DriverAidWindow">
            <summary>
            Responsible for displaying a speedometer showing current speed, as well as the 
            maximum speed the driver may go, as defined by the brake curve. Such a system is 
            a key ingredient in train control systems.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.TICK_OUTER_Y">
            <summary>
            Defines the Y coordinate of the top most point of a gauge tick,
            if the gauge tick is vertical.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.TICK_INNER_Y">
            <summary>
            Defines the Y coordinate of the bottom most point of a gauge tick,
            if the gauge tick is vertical.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.TICK_WIDTH">
            <summary>
            Width of each gauge tick.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.LABEL_Y">
            <summary>
            Defines the Y coordinate of the center of a gauge label, if the label 
            is drawn vertically above the center of the gauge.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.LABEL_FONT_SIZE">
            <summary>
            Font size, in pixels of gauge labels.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.GAUGE_SIZE">
            <summary>
            Defines the size of the gauge, in pixels.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.MARGIN_LEFT">
            <summary>
            Defines how much space to th left of the gauge is reserved for the distance bar.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.SPEED_WARN_BOTTOM_MARGIN">
            <summary>
            Defines the space, in pixels, between the bottom of the speed warning box,
            and the top of the distance box.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.TARGETSPEED_Y">
            <summary>
            Vertical position of the target speed box.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.TARGETSPEED_W">
            <summary>
            Target speed box width.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.TARGETSPEED_H">
            <summary>
            Target speed box height.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.CURVE_BAR_SEGMENT_SIZE">
            <summary>
            Size of each curved bar, in degrees.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.MIN_BRAKE_WARN_BOX_SIZE">
            <summary>
            Minumum brake warning box size.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.MAX_BRAKE_WARN_BOX_SIZE">
            <summary>
            Maximum brake warning box size.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.BaseTexture">
            <summary>
            The speedometer texture.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.NeedleTexture">
            <summary>
            The texture of the primary needle in front of the speedometer texture.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.BrakeCurveTexture">
            <summary>
            The texure of the indicator that shows the current brake curve.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.SpeedFont">
            <summary>
            Font used to indicate the current target speed.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.SpeedFontSmall">
            <summary>
            Font used to indicate the the current speed of the train.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.SolidTextures">
            <summary>
            Contains the single-pixel solid color textures for drawing items other than the speedometer and curved bars.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.MinAngle">
            <summary>
            Angle of the needle (degrees) when showing "0".
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.MaxAngle">
            <summary>
            Angle of the needle (degrees) when showing MaxSpeed;
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.MaxSpeed">
            <summary>
            Maximum displayable speed, in kmh.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.NEEDLE_WIDTH">
            <summary>
            Defines the width of the needle, in pixels.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.NEEDLE_HEIGHT">
            <summary>
            Defines the height of the needle, in pixels.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.INDICATOR_WIDTH">
            <summary>
            Defines the width of the brake curve indicator bitmap, in pixels.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.INDICATOR_HEIGHT">
            <summary>
            Defines the height of the brake curve indicator bitmap, in pixels.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.SpeedLabels">
            <summary>
            These are the labels to show on the speedo.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.DrawGaugeLabels">
            <summary> 
            True when we should draw the gauge labels.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.TargetDistanceRect">
            <summary>
            Defines the area that a full target distance bar occupies.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.TargetDistanceKeyPoints">
            <summary>
            Non-linearity table defining the distance bar behaviour
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.CurrentSpeedAngle">
            <summary>
            The current angle of the needle, in radians.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.CurrentSpeed">
            <summary>
            Current speed of the train, in kmh.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.CurrentBrakeCurveAngle">
            <summary>
            The current angle of the brake curve indicator.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.CurrentBrakeCurveSpeed">
            <summary>
            The current speed of the brake curve, in kmh.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.CurrentDistanceHeight">
            <summary>
            The current value of the target distance bar, in the range 0 -> 1.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.CurrentTargetSpeed">
            <summary>
            Stores the current target speed.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.CurrentTargetSpeedString">
            <summary>
            The string to display as the current target speed.
            </summary>
        </member>
        <member name="F:ORTS.Popups.DriverAid.CurrentSpeedString">
            <summary>
            The string to display as the current speed.
            </summary>
        </member>
        <member name="M:ORTS.Popups.DriverAid.UpdateSpeed(System.Single)">
            <summary>
            Updates the current speed, in kmh.
            </summary>
        </member>
        <member name="M:ORTS.Popups.DriverAid.UpdateBrakeCurveSpeed(System.Single)">
            <summary>
            Updates the current brake speed, in kmh.
            </summary>
        </member>
        <member name="M:ORTS.Popups.DriverAid.UpdateTargetDistance(System.Single)">
            <summary>
            Updates the current target distance, in metres.
            </summary>
            <param name="distance"></param>
        </member>
        <member name="M:ORTS.Popups.DriverAid.SpeedToAngle(System.Single)">
            <summary>
            Given a speed in kmh, convert to gauge angle, in radians.
            </summary>
            <param name="speed"></param>
            <returns></returns>
        </member>
        <member name="M:ORTS.Popups.DriverAid.GetWarningBoxTexture">
            <summary>
            Returns the correct texture to use for the warning box, as
            it is sometimes a different color than the other "common" elements.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ORTS.Popups.DriverAid.GetStandardColorTexture">
            <summary>
            Returns the correct texture to use for many elements in the driver aid.
            The texture depends large on how fast the train is going relative to its brake curve.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ORTS.Popups.DriverAid.GenerateNeedle(System.Drawing.Size,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Generates a generic speedometer for use with a Texture2D.
            </summary>
            <param name="sz"></param>
            <param name="center"></param>
            <returns></returns>
        </member>
        <member name="M:ORTS.Popups.DriverAid.GenerateBrakeCurveTexture(System.Drawing.Size)">
            <summary>
            Generates a triangular indicator, and formats the result
            for use on a Texture2D.
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:ORTS.Popups.DriverAid.DrawBrakeIndicator(System.Drawing.Graphics,System.Int32,System.Int32)">
            <summary>
            Generates a triangular indicator.
            </summary>
            <param name="g"></param>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="M:ORTS.Popups.DriverAid.DrawNeedle(System.Drawing.Graphics,System.Drawing.Size,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Draws a generic speedometer needle.
            </summary>
            <param name="g"></param>
            <param name="sz"></param>
            <param name="center"></param>
        </member>
        <member name="M:ORTS.Popups.DriverAid.BitmapToBytes(System.Drawing.Bitmap)">
            <summary>
            Given a bitmap, convert it to an array of bytes for use in a Texture2D.
            </summary>
            <param name="bitmap"></param>
            <returns></returns>
        </member>
        <member name="P:ORTS.Popups.DriverAid.SpeedWarningBoxCentre">
            <summary>
            Defines the centre of the Speed Warning Box(above the target distant rectangle).
            </summary>
        </member>
        <member name="T:ORTS.Popups.DriverAid.DisplayColors">
            <summary>
            Defines different levels of "warning".
            </summary>
        </member>
        <member name="T:ORTS.Interlocking.SwitchState">
            <summary>
            Defines possible states of the switch. 
            </summary>
        </member>
        <member name="T:ORTS.Interlocking.InterlockingSwitch">
            <summary>
            Provides an abstraction atop an underlying switch object.
            </summary>
        </member>
        <member name="F:ORTS.Interlocking.InterlockingSwitch.TrJunctionNodeIndex">
            <summary>
            Defines the index number of the underlying TrJunctionNode.
            </summary>
        </member>
        <member name="F:ORTS.Interlocking.InterlockingSwitch.BaseNode">
            <summary>
            The base node of the switch.
            </summary>
        </member>
        <member name="F:ORTS.Interlocking.InterlockingSwitch.LeftLeadingNode">
            <summary>
            The left-leading node of the switch.
            </summary>
        </member>
        <member name="F:ORTS.Interlocking.InterlockingSwitch.RightLeadingNode">
            <summary>
            The right-leading node of the switch.
            </summary>
        </member>
        <member name="M:ORTS.Interlocking.InterlockingSwitch.Throw">
            <summary>
            Throws switch if possible.
            </summary>
        </member>
        <member name="M:ORTS.Interlocking.InterlockingSwitch.ComputeGeometry">
            <summary>
            Initialises some of the switch properties based on the underlying network topology.
            </summary>
        </member>
        <member name="M:ORTS.Interlocking.InterlockingSwitch.ComputeBranches(System.Collections.Generic.Dictionary{MSTS.TrVectorNode[],System.Single},MSTS.TrVectorNode@,MSTS.TrVectorNode@,MSTS.TrVectorNode@)">
            <summary>
            Computes the branches/nodes of the switch.
            </summary>
            <param name="angles"></param>
            <returns></returns>
        </member>
        <member name="M:ORTS.Interlocking.InterlockingSwitch.DetermineAngles(MSTS.TrackNode[])">
            <summary>
            Determines the angles of the switch. Useful for computing properties
            related to the geometry of a switch.
            </summary>
            <param name="connections"></param>
            <returns></returns>
        </member>
        <member name="P:ORTS.Interlocking.InterlockingSwitch.SpeedLeftLeading">
            <summary>
            Defines the maximum speed in m/s through the switch via the left leading position.
            </summary>
        </member>
        <member name="P:ORTS.Interlocking.InterlockingSwitch.SpeedRightLeading">
            <summary>
            Defines the maximum speed in m/s through the switch via the right leading position.
            </summary>
        </member>
        <member name="P:ORTS.Interlocking.InterlockingSwitch.IsManuallyLocked">
            <summary>
            True when switch is manually locked by the dispatcher.
            </summary>
        </member>
        <member name="P:ORTS.Interlocking.InterlockingSwitch.IsRouteLocked">
            <summary>
            True when the switch has been locked as part of a route.
            </summary>
        </member>
        <member name="P:ORTS.Interlocking.InterlockingSwitch.IsOccupied">
            <summary>
            Returns true if any of the connected tracks are occupied.
            </summary>
        </member>
        <member name="P:ORTS.Interlocking.InterlockingSwitch.IsLocked">
            <summary>
            True if locked for any reason.
            </summary>
        </member>
        <member name="P:ORTS.Interlocking.InterlockingSwitch.CanThrow">
            <summary>
            Returns true when this switch can be thrown (commanded to change position)
            </summary>
        </member>
        <member name="M:ORTS.Interlocking.InterlockingBuffer.#ctor(ORTS.Simulator,MSTS.TrackNode)">
            <summary>
            Creates a new InterlockingBuffer.
            </summary>
            <param name="simulator"></param>
            <param name="trackNode"></param>
        </member>
        <member name="M:ORTS.TimeTable.#ctor(ORTS.Dispatcher)">
            <summary>
            Processes AI train paths in priority order to construct a feasible timetable.
            </summary>
        </member>
        <member name="M:ORTS.TimeTable.CalcTrackTimes(System.Double,System.Double,ORTS.AIPathNode,ORTS.TTTrainTimes,System.Int32)">
            <summary>
            Recursive function that tries to built a list of times for a train that does not overlap any trains already in the timetable.
            Returns the number of seconds the train needs to wait at a previous node.
            </summary>
        </member>
        <member name="M:ORTS.TimeTable.CanAdd(ORTS.TTTrainTimes)">
            <summary>
            Returns true if a new train can be added to the timetable without overlapping an existing train.
            </summary>
        </member>
        <member name="M:ORTS.TimeTable.Add(ORTS.TTTrainTimes)">
            <summary>
            Adds a train to the timetable if possible.
            </summary>
        </member>
        <member name="M:ORTS.TimeTable.TestAdd(System.Int32,System.Double,System.Double)">
            <summary>
            Returns true if the specified track and time interval can be added to the timetable without overlapping an existing train.
            </summary>
        </member>
        <member name="T:ORTS.TTTrainTimes">
            <summary>
            Class used to store timetable times for a single train.
            Times are saved by track node index.
            </summary>
        </member>
        <member name="M:ORTS.TTTrainTimes.Add(System.Int32,System.Double,System.Double)">
            <summary>
            Adds an entry for the specified track node.
            </summary>
        </member>
        <member name="M:ORTS.TTTrainTimes.Overlap(ORTS.TTTrainTimes)">
            <summary>
            Returns true if any of two trains's time intervals overlap.
            </summary>
        </member>
        <member name="T:ORTS.TimeTableTime">
            <summary>
            Struct to store and compare timetable time intervals.
            </summary>
        </member>
        <member name="M:ORTS.TimeTableTime.Overlap(ORTS.TimeTableTime)">
            <summary>
            Returns true if two time intervals overlap.
            </summary>
        </member>
        <member name="F:ORTS.Simulator.GameTime">
            <summary>
            Monotonically increasing time value (in seconds) for the simulation. Starts at 0 and only ever increases, at <see cref="F:ORTS.Simulator.GameSpeed"/>.
            Does not change if game is <see cref="F:ORTS.Simulator.Paused"/>.
            </summary>
        </member>
        <member name="F:ORTS.Simulator.ClockTime">
            <summary>
            "Time of day" clock value (in seconds) for the simulation. Starts at activity start time and may increase, at <see cref="F:ORTS.Simulator.GameSpeed"/>,
            or jump forwards or jump backwards.
            </summary>
        </member>
        <member name="F:ORTS.Simulator.InterlockingSystem">
            <summary>
            Reference to the InterlockingSystem object, responsible for
            managing signalling and interlocking.
            </summary>
        </member>
        <member name="M:ORTS.Simulator.InitialPlayerLocomotive">
            <summary>
            Which locomotive does the activity specify for the player.
            </summary>
        </member>
        <member name="M:ORTS.Simulator.GetElapsedClockSeconds(System.Single)">
            <summary>
            Convert and elapsed real time into clock time based on simulator
            running speed and paused state.
            </summary>
        </member>
        <member name="M:ORTS.Simulator.Update(System.Single)">
            <summary>
            Update the simulator state 
            elapsedClockSeconds represents the the time since the last call to Simulator.Update
            Executes in the UpdaterProcess thread.
            </summary>
        </member>
        <member name="M:ORTS.Simulator.CheckForCoupling(ORTS.Train,System.Single)">
            <summary>
            Scan other trains
            </summary>
        </member>
        <member name="M:ORTS.Simulator.AlignTrailingPointSwitches(ORTS.Train,System.Boolean)">
            <summary>
            Sets the trailing point switches ahead of the train
            </summary>
        </member>
        <member name="M:ORTS.Simulator.AlignSwitchesToDefault">
            <summary>
            The TSECTION.DAT specifies which path through a switch is considered the main route
            For most switches the main route is the straight-through route, vs taking the curved branch
            All the switch tracks in a route are stored in the TDB 
            This method scans the route's TDB, aligning each switch to the main route.
            </summary>
        </member>
        <member name="M:ORTS.Simulator.SwitchTrackBehind(ORTS.Train)">
            <summary>
            Align the switchtrack behind the players train to the opposite position
            </summary>
        </member>
        <member name="M:ORTS.Simulator.SwitchTrackAhead(ORTS.Train)">
            <summary>
            Align the switchtrack ahead of the players train to the opposite position
            </summary>
        </member>
        <member name="M:ORTS.Simulator.InitializeStaticConsists">
            <summary>
            Set up trains based on info in the static consists listed in the activity file.
            </summary>
        </member>
        <member name="M:ORTS.Simulator.XNAMatrixFromMSTSCoordinates(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            The front end of a railcar is at MSTS world coordinates x1,y1,z1
            The other end is at x2,y2,z2
            Return a rotation and translation matrix for the center of the railcar.
            </summary>
        </member>
        <member name="T:MSTS.STFReader">
            <summary>Used for reading data from Structured Text Format (MSTS1 style) files.
            </summary><remarks><para>
            An STF file is whitespace delimitered file, taking the format - {item}{whitespace}[repeated].</para><para>
             </para><para>
            At it's most simple an STF file has the format - {token_item}{whitespace}{data_item}{whitespace}(repeated)</para><para>
            Even, more simplisitically every {data_item} can be a {constant_item}</para>
            <code lang="STF" title="STF Example"><para>
                Example:</para><para>
                name SimpleSTFfile</para><para>
                weight 100</para><para>
                speed 50.25</para>
            </code> <para>
            STF also has a block methodology where a {data_item} following a {token_item} can start with '(' followed by any number of {data_item}s and closed with a ')'.
            The contents of the block are defined in the specific file schema, and not in the STF definition.
            The STF defintion allows that inside a pair of parentheses may be a single {constant_item}, multiple whitespace delimitered {constant_item}s, or a nested {token_item}{data_item} pair (which could contain a further nested block recursively).</para>
            <code lang="STF" title="STF Example"><para>
                Example:</para><para>
                name BlockedSTFfile</para><para>
                root_constant 100</para><para>
                root_block_1</para><para>
                (</para><para>
                      nested_block_1_1</para><para>
                      (</para><para>
                            1</para><para>
                      )</para><para>
                      nested_block_1_2 ( 5 )</para><para>
                )</para><para>
                root_block_2</para><para>
                (</para><para>
                      1 2 3</para><para>
                )</para><para>
                root_block_3 ( a b c )</para>
            </code> <para>
            Numeric {constan_item}s can include a 'unit' suffix, which is handled in the ReadDouble() function.</para><para>
            Within ReadDouble these units are then converted to the standards used throughout OR - meters, newtons, kilograms.</para>
            <code lang="STF" title="STF Example"><para>
                Example:</para><para>
                name STFfileWithUnits</para><para>
                weight 100kg</para><para>
                speed 50mph</para>
            </code> <para>
            Whitespaces can be included within any {item} using a double quotation notation.
            Quoted values also support a trailing addition operator to indicate an append operation of multiple quoted strings.</para><para>
            Although append operations are technically allowed for {token_item}'s this practice is *strongly* discouraged for readability.</para>
            <code lang="STF" title="STF Example"><para>
                Example:</para><para>
                simple_token "Data Item with" + " whitespace"</para><para>
                block_token ( "Data " + "Item 1" "Data Item 2" )</para><para>
                "discouraged_" + "token" -1</para><para>
                Error Example:</para><para>
                error1 "You cannot use append suffix to non quoted " + items</para>
            </code> <para>
            The STF format also supports 3 special {token_item}s - include, comment &amp; skip.</para><list class="bullet">
            <listItem><para>include - must be at the root level (that is to say it cannot be included within a block).
            After an include directive the {constant_item} is a filename relative to the current processing STF file.
            The include token has the effect of in-lining the defined file into the current document.</para></listItem>
            <listItem><para>comment &amp; skip - must be followed by a block which will not be processed in OR</para></listItem>
            </list> <para>
            Finally any token which begins with a '#' character will be ignored, and then the next {data_item} (constant or block) will not be processed.</para><para>
             </para>
            <alert class="important"><para>NB!!! If a comment/skip/#*/_* is the last {item} in a block, rather than being totally consumed a dummy "#\u00b6" is returned, so if EndOFBlock() returns false, you always get an {item} (which can then just be ignored).</para></alert>
            </remarks>
            <example><code lang="C#" title="STF parsing using Parse...() and delegate/lambda functions in C#">
                using (STFReader stf = new STFReader(filename, false))
                    stf.ParseFile(new STFReader.TokenProcessor[] {
                        new STFReader.TokenProcessor("item_single_constant", ()=&gt;{ float isc = stf.ReadFloat(STFReader.UNITS.None, 0); }),
                        new STFReader.TokenProcessor("item_single_speed", ()=&gt;{ float iss_mps = stf.ReadFloat(STFReader.UNITS.Speed, 0); }),
                        new STFReader.TokenProcessor("block_single_constant", ()=&gt;{ float bsc = stf.ReadFloatBlock(STFReader.UNITS.None, 0); }),
                        new STFReader.TokenProcessor("block_fixed_format", ()=&gt;{
                            stf.MustMatch("(");
                            int bff1 = stf.ReadInt(STFReader.UNITS.None, 0);
                            string bff2 = stf.ReadString();
                            stf.SkipRestOfBlock();
                        }),
                        new STFReader.TokenProcessor("block_variable_contents", ()=&gt;{ stf.MustMatch("("); stf.ParseBlock(new STFReader.TokenProcessor[] {
                            new STFReader.TokenProcessor("subitem", ()=&gt;{ string si = stf.ReadString(); }),
                            new STFReader.TokenProcessor("subblock", ()=&gt;{ string sb = stf.ReadStringBlock(""); }),
                        });}),
                    });
            </code></example>
            <example><code lang="C#" title="Alternate functional method to parse STF using C#">
                   using (STFReader stf = new STFReader(filename, false))
                       while (!stf.EOF)
                           switch (stf.ReadItem().ToLower())
                           {
                               case "item_single_constant": float isc = stf.ReadFloat(STFReader.UNITS.None, 0); break;
                               case "item_single_speed": float iss_mps = stf.ReadFloat(STFReader.UNITS.Speed, 0); break;
                               case "block_single_constant": float bsc = stf.ReadFloatBlock(STFReader.UNITS.None, 0); break;
                               case "block_fixed_format":
                                   stf.MustMatch("(");
                                   int bff1 = stf.ReadInt(STFReader.UNITS.None, 0);
                                   string bff2 = stf.ReadString();
                                   stf.SkipRestOfBlock();
                                   break;
                               case "block_variable_contents":
                                   stf.MustMatch("(");
                                   while (!stf.EndOfBlock())
                                       switch (stf.ReadItem().ToLower())
                                       {
                                           case "subitem": string si = stf.ReadString(); break;
                                           case "subblock": string sb = stf.ReadStringBlock(""); break;
                                           case "(": stf.SkipRestOfBlock();
                                       }
                                   break;
                               case "(": stf.SkipRestOfBlock(); break;
                           }
            </code></example>
            <exception cref="T:MSTS.STFException"><para>
            STF reports errors using the  exception static members</para><para>
            There are three broad categories of error</para><list class="bullet">
            <listItem><para>Failure - Something which prevents loading from continuing, this throws an unhandled exception and drops out of Open Rails.</para></listItem>
            <listItem><para>Error - The data read does not have logical meaning - STFReader does not generate these errors, this is only appropriate STFReader consumers who understand the context of the data being processed</para></listItem>
            <listItem><para>Warning - When an error which can be programatically recovered from should be reported back to the user</para></listItem>
            </list>
            </exception>
        </member>
        <member name="M:MSTS.STFReader.#ctor(System.String,System.Boolean)">
            <summary>Open a file, reader the header line, and prepare for STF parsing
            </summary>
            <param name="filename">Filename of the STF file to be opened and parsed.</param>
            <param name="useTree"><para>true - if the consumer is going to use the Tree Property as it's parsing method (MSTS wagons &amp; engines)</para>
            <para>false - if Tree is not used which signicantly reduces GC</para></param>
        </member>
        <member name="M:MSTS.STFReader.#ctor(System.IO.Stream,System.String,System.Text.Encoding,System.Boolean)">
            <summary>Use an open stream for STF parsing, this constructor assumes that the SIMIS signature has already been gathered (or there isn't one)
            </summary>
            <param name="inputStream">Stream that will be parsed.</param>
            <param name="fileName">Is only used for error reporting.</param>
            <param name="encoding">One of the Encoding formats, defined as static members in Encoding which return an Encoding type.  Eg. Encoding.ASCII or Encoding.Unicode</param>
            <param name="useTree"><para>true - if the consumer is going to use the Tree Property as it's parsing method (MSTS wagons &amp; engines)</para>
            <para>false - if Tree is not used which signicantly reduces GC</para></param>
        </member>
        <member name="M:MSTS.STFReader.Dispose">
            <summary>Implements the IDisposable interface so this class can be implemented with the 'using(STFReader r = new STFReader(...)) {...}' C# statement.
            </summary>
        </member>
        <member name="M:MSTS.STFReader.Dispose(System.Boolean)">
            <summary>Releases the resources used by the STFReader.
            </summary>
            <param name="disposing">
            <para>true - release managed and unmanaged resources.</para>
            <para>false - release only unmanaged resources.</para>
            </param>
        </member>
        <member name="M:MSTS.STFReader.ReadItem">
            <summary>Returns the next whitespace delimited {item} from the STF file skipping comments, etc.
            </summary>
            <remarks>
            <alert class="important">If a comment/skip/#*/_* ignore block is the last {item} in a block, rather than being totally consumed a dummy '#' is returned, so if EndOFBlock() returns false, you always get an {item} (which can then just be ignored).</alert>
            </remarks>
            <returns>The next {item} from the STF file, any surrounding quotations will be not be returned.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadItem(System.Boolean)">
            <summary>This is an internal function in STFReader, it returns the next whitespace delimited {item} from the STF file.
            </summary>
            <remarks>
            <alert class="important">If a comment/skip/#*/_* ignore block is the last {item} in a block, rather than being totally consumed a dummy '#' is returned, so if EndOFBlock() returns false, you always get an {item} (which can then just be ignored).</alert>
            </remarks>
            <param name="string_mode">When true normal comment processing is disabled.</param>
            <returns>The next {item} from the STF file, any surrounding quotations will be not be returned.</returns>
        </member>
        <member name="M:MSTS.STFReader.StepBackOneItem">
            <summary>Calling this function causes ReadItem() to repeat the last {item} that was read from the STF file
            </summary>
            <remarks>
            <para>The current implementation of StepBackOneItem() only allows for one "step back".</para>
            <para>This means that there each call to StepBackOneItem() must have an intervening call to ReadItem().</para>
            </remarks>
        </member>
        <member name="M:MSTS.STFReader.MustMatch(System.String)">
            <summary>Reports a critical error if the next {item} does not match the target.
            </summary>
            <param name="target">The next {item} contents we are expecting in the STF file.</param>
            <returns>The {item} read from the STF file</returns>
        </member>
        <member name="M:MSTS.STFReader.EndOfBlock">
            <summary>Returns true if the next character is the end of block, or end of file. Consuming the closing ")" all other values are not consumed.
            </summary>
            <remarks>
            <para>An STF block should be enclosed in parenthesis, ie ( {data_item} {data_item} )</para>
            </remarks>
            <returns>
            <para>true - An EOF, or closing parenthesis was found and consumed.</para>
            <para>false - Another type of {item} was found but not consumed.</para>
            </returns>
        </member>
        <member name="M:MSTS.STFReader.SkipBlock">
            <summary>Read a block open (, and then consume the rest of the block without processing.
            If we find an immediate close ), then produce a warning, and return without consuming the parenthesis.
            </summary>
        </member>
        <member name="M:MSTS.STFReader.SkipRestOfBlock">
            <summary>Skip to the end of this block, ignoring any nested blocks
            </summary>
        </member>
        <member name="M:MSTS.STFReader.ReadString">
            <summary>Return next whitespace delimited string from the STF file.
            </summary>
            <remarks>
            <alert class="important">This differs from ReadInt in that normal comment processing is disabled.  ie an item that starts with _ is returned and not skipped.</alert>
            </remarks>
            <returns>The next {string_item} from the STF file, any surrounding quotations will be not be returned.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadHex(System.Nullable{System.UInt32})">
            <summary>Read an hexidecimal encoded number {constant_item}
            </summary>
            <param name="default_val">the default value if an unexpected ')' token is found</param>
            <returns>The next {constant_item} from the STF file.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadInt(MSTS.STFReader.UNITS,System.Nullable{System.Int32})">
            <summary>Read an signed integer {constant_item}
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">the default value if an unexpected ')' token is found</param>
            <returns>The next {constant_item} from the STF file, with the suffix normalized to OR units.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadUInt(MSTS.STFReader.UNITS,System.Nullable{System.UInt32})">
            <summary>Read an unsigned integer {constant_item}
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">the default value if an unexpected ')' token is found</param>
            <returns>The next {constant_item} from the STF file, with the suffix normalized to OR units.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadFloat(MSTS.STFReader.UNITS,System.Nullable{System.Single})">
            <summary>Read an single precision floating point number {constant_item}
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">the default value if an unexpected ')' token is found</param>
            <returns>The next {constant_item} from the STF file, with the suffix normalized to OR units.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadDouble(MSTS.STFReader.UNITS,System.Nullable{System.Double})">
            <summary>Read an double precision floating point number {constant_item}
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">the default value if an unexpected ')' token is found</param>
            <returns>The next {constant_item} from the STF file, with the suffix normalized to OR units.</returns>
        </member>
        <member name="M:MSTS.STFReader.ParseUnitSuffix(System.String@,MSTS.STFReader.UNITS)">
            <summary>This function removes known unit suffixes, and returns a scaler to bring the constant into the standard OR units.
            </summary>
            <remarks>This function is marked internal so it can be used to support arithmetic processing once the elements are seperated (eg. 5*2m)
            </remarks>
            <param name="constant">string with suffix (ie "23 mph"), after the function call the suffix is removed.</param>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <returns>The scaler that should be used to modify the constant to standard OR units.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadStringBlock(System.String)">
            <summary>Read an string constant from the STF format '( {string_constant} ... )'
            </summary>
            <param name="default_val">the default value if the item is not found in the block.</param>
            <returns>The first item inside the STF block.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadIntBlock(MSTS.STFReader.UNITS,System.Nullable{System.Int32})">
            <summary>Read an integer constant from the STF format '( {int_constant} ... )'
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">the default value if the constant is not found in the block.</param>
            <returns>The STF block with the first {item} converted to a integer constant.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadUIntBlock(MSTS.STFReader.UNITS,System.Nullable{System.UInt32})">
            <summary>Read an unsigned integer constant from the STF format '( {uint_constant} ... )'
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">the default value if the constant is not found in the block.</param>
            <returns>The STF block with the first {item} converted to a unsigned integer constant.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadFloatBlock(MSTS.STFReader.UNITS,System.Nullable{System.Single})">
            <summary>Read an single precision constant from the STF format '( {float_constant} ... )'
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">the default value if the constant is not found in the block.</param>
            <returns>The STF block with the first {item} converted to a single precision constant.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadDoubleBlock(MSTS.STFReader.UNITS,System.Nullable{System.Double})">
            <summary>Read an double precision constant from the STF format '( {double_constant} ... )'
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">the default value if the constant is not found in the block.</param>
            <returns>The STF block with the first {item} converted to a double precision constant.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadBoolBlock(System.Boolean)">
            <summary>Reads the first item from a block in the STF format '( {double_constant} ... )' and return true if is not-zero or 'true'
            </summary>
            <param name="default_val">the default value if a item is not found in the block.</param>
            <returns><para>true - If the first {item} in the block is non-zero or 'true'.</para>
            <para>false - If the first {item} in the block is zero or 'false'.</para></returns>
        </member>
        <member name="M:MSTS.STFReader.ReadVector3Block(MSTS.STFReader.UNITS,Microsoft.Xna.Framework.Vector3)">
            <summary>Read a Vector3 object in the STF format '( {X} {Y} {Z} ... )'
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">The default vector if any of the values are not specified</param>
            <returns>The STF block as a Vector3</returns>
        </member>
        <member name="M:MSTS.STFReader.ParseFile(MSTS.STFReader.TokenProcessor[])">
            <summary>Parse an STF file until the EOF, using the array of lower case tokens, with a processor delegate/lambda
            </summary>
            <param name="processors">Array of lower case token, and the delegate/lambda to call when matched.</param>
        </member>
        <member name="M:MSTS.STFReader.ParseFile(MSTS.STFReader.ParsingBreak,MSTS.STFReader.TokenProcessor[])">
            <summary>Parse an STF file until the EOF, using the array of lower case tokens, with a processor delegate/lambda
            </summary>
            <param name="breakout">A delegate that returns true, if the processing should be halted prematurely</param>
            <param name="processors">Array of lower case token, and the delegate/lambda to call when matched.</param>
        </member>
        <member name="M:MSTS.STFReader.ParseBlock(MSTS.STFReader.TokenProcessor[])">
            <summary>Parse an STF file until the end of block ')' marker, using the array of lower case tokens, with a processor delegate/lambda
            </summary>
            <param name="processors">Array of lower case token, and the delegate/lambda to call when matched.</param>
        </member>
        <member name="M:MSTS.STFReader.ParseBlock(MSTS.STFReader.ParsingBreak,MSTS.STFReader.TokenProcessor[])">
            <summary>Parse an STF file until the end of block ')' marker, using the array of lower case tokens, with a processor delegate/lambda
            </summary>
            <param name="breakout">A delegate that returns true, if the processing should be halted prematurely</param>
            <param name="processors">Array of lower case token, and the delegate/lambda to call when matched.</param>
        </member>
        <member name="F:MSTS.STFReader.streamSTF">
            <summary>The I/O stream for the STF file we are processing
            </summary>
        </member>
        <member name="F:MSTS.STFReader.includeReader">
            <summary>includeReader is used recursively in ReadItem() to handle the 'include' token, file include mechanism
            </summary>
        </member>
        <member name="F:MSTS.STFReader.previousItem">
            <summary>Remembers the last returned ReadItem().  If the next {item] is a '(', this is the block name used in the tree.
            </summary>
        </member>
        <member name="F:MSTS.STFReader.block_depth">
            <summary>How deep in nested blocks the current parser is
            </summary>
        </member>
        <member name="F:MSTS.STFReader.tree">
            <summary>A list describing the hierachy of nested block tokens
            </summary>
        </member>
        <member name="F:MSTS.STFReader.tree_cache">
            <summary>The tree cache is used to minimize the calls to StringBuilder when Tree is called repetively for the same hierachy.
            </summary>
        </member>
        <member name="F:MSTS.STFReader.stepbackoneitemFlag">
            <summary>This flag is set in StepBackOneItem(), and causes ReadItem(), to use the stepback* variables to do an item repeat
            </summary>
        </member>
        <member name="F:MSTS.STFReader.itemBuilder">
            <summary>This is really a local variable in the function ReadItem(...) but it is a class member to stop unnecessary memory re-allocations.
            </summary>
        </member>
        <member name="M:MSTS.STFReader.ReadItem(System.Boolean,System.Boolean)">
            <summary>Internal Implementation - This is the main function that reads an item from the STF stream.
            </summary>
            <param name="skip_mode">True - we are in a skip function, and so we don't want to do any special token processing.</param>
            <param name="string_mode">True - we are expecting a string, so don't skip comments.</param>
            <returns>The next item from the STF file</returns>
        </member>
        <member name="M:MSTS.STFReader.UpdateTreeAndStepBack(System.String)">
            <summary>Internal Implementation
            <para>This function is called by ReadItem() for every item read from the STF file (and Included files).</para>
            <para>If a block instuction is found, then tree list is updated.</para>
            <para>As this function is called once per ReadItem() is stores the previous value in stepback* variables (there is additional optimization that we only copy stepbackTree if the tree has changed.</para>
            <para>Now when the stepbackoneitemFlag flag is set, we use the stepback* copies, to move back exactly one item.</para>
            </summary>
            <param name="token"></param>
        </member>
        <member name="P:MSTS.STFReader.EOF">
            <summary>Property that returns true when the EOF has been reached
            </summary>
        </member>
        <member name="P:MSTS.STFReader.FileName">
            <summary>Filename property for the file being parsed - for reporting purposes
            </summary>
        </member>
        <member name="P:MSTS.STFReader.LineNumber">
            <summary>Line Number property for the file being parsed - for reporting purposes
            </summary>
        </member>
        <member name="P:MSTS.STFReader.SIMISsignature">
            <summary>SIMIS header read from the first line of the file being parsed
            </summary>
        </member>
        <member name="P:MSTS.STFReader.Tree">
            <summary>Property returning the last {item} read using ReadItem() prefixed with string describing the nested block hierachy.
            <para>The string returned is formatted 'rootnode(nestednode(childnode(previous_item'.</para>
            </summary>
            <remarks>
            Tree is expensive method of reading STF files (especially for the GC) and should be avoided if possible.
            </remarks>
        </member>
        <member name="T:MSTS.STFReader.UNITS">
            <summary>Enumeration limiting which units are valid when parsing a numeric constant.
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.None">
            <summary>No unit parsing is done on the {constant_item} - which is obviously fastest
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.Compulsary">
            <summary>Combined using an | with other UNITS if the unit is compulsary (compulsary units will slow parsing)
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.Distance">
            <summary>Valid Units: m, cm, mm, km, ft, ', in, "
            <para>Scaled to meters.</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.Speed">
            <summary>Valid Units: m/s, mph, kph, kmh, km/h
            <para>Scaled to meters/second.</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.Mass">
            <summary>Valid Units: kg, t, lb
            <para>Scaled to kilograms.</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.Force">
            <summary>Valid Units: n, kn, lbf
            <para>Scaled to newtons.</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.Power">
            <summary>Valid Units: w, kw, hp
            <para>Scaled to watts.</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.Stiffness">
            <summary>Valid Units: n/m
            <para>Scaled to newtons/metre.</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.Resistance">
            <summary>Valid Units: n/m/s (+ '/m/s' in case the newtons is missed) 
            <para>Scaled to newtons/speed(m/s)</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.MassRate">
            <summary>Valid Units: lb/h
            <para>Scaled to pounds per hour.</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.Volume">
            <summary>Valid Units: *(ft^3)
            <para>Scaled to cubic feet.</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.Pressure">
            <summary>Valid Units: psi
            <para>Scaled to pounds per square inch.</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.Area">
            <summary>Valid Units: *(ft^2)
            <para>Scaled to square meters.</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.EnergyDensity">
            <summary>Valid Units: kj/kg, j/g, btu/lb
            <para>Scaled to kj/kg.</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.UNITS.Any">
            <summary>This is only provided for backwards compatibility - all new users should limit the units to appropriate types
            </summary>
        </member>
        <member name="T:MSTS.STFReader.Processor">
            <summary>This delegate definition is used by the ParseFile and ParseBlock methods, and is called when an associated matching token is found.
            </summary>
        </member>
        <member name="T:MSTS.STFReader.ParsingBreak">
            <summary>This delegate definition is used by the ParseFile and ParseBlock methods, and is used to break out of the processing loop prematurely.
            </summary>
            <returns>true - if the parsing should be aborted prematurely</returns>
        </member>
        <member name="T:MSTS.STFReader.TokenProcessor">
            <summary>A structure used to index lambda functions to a lower cased token.
            </summary>
        </member>
        <member name="M:MSTS.STFReader.TokenProcessor.#ctor(System.String,MSTS.STFReader.Processor)">
            <summary>This constructor is used for the arguments to ParseFile and ParseBlock.
            </summary>
            <param name="t">The lower case token.</param>
            <param name="p">A lambda function or delegate that will be called from the Parse...() method.</param>
        </member>
        <member name="T:MSTS.STFReader.STEPBACK">
            <summary>Internal Structure used to group together the variables used to implement step back functionality.
            </summary>
        </member>
        <member name="F:MSTS.STFReader.STEPBACK.Item">
            <summary>The stepback* variables store the previous state, so StepBackOneItem() can jump back on {item}. stepbackItem « ReadItem() return
            </summary>
        </member>
        <member name="F:MSTS.STFReader.STEPBACK.PrevItem">
            <summary>The stepback* variables store the previous state, so StepBackOneItem() can jump back on {item}. stepbackCurrItem « previousItem
            </summary>
        </member>
        <member name="F:MSTS.STFReader.STEPBACK.Tree">
            <summary>The stepback* variables store the previous state, so StepBackOneItem() can jump back on {item}. stepbackTree « tree
            <para>This item, is optimized, so when value is null it means stepbackTree was the same as Tree, so we don't create unneccessary memory duplicates of lists.</para>
            </summary>
        </member>
        <member name="F:MSTS.STFReader.STEPBACK.BlockDepth">
            <summary>The stepback* variables store the previous state, so StepBackOneItem() can jump back on {item}. BlockDepth « block_depth
            </summary>
        </member>
        <member name="M:MSTS.TrackShapes.Get(System.UInt32)">
            <summary>
            Returns the TrackShape corresponding to the given index value.
            </summary>
            <param name="targetShapeIndex">The index value of the desired TrackShape.</param>
            <returns>The requested TrackShape.</returns>
        </member>
        <member name="T:ORTS.SceneryShader">
            <summary>
            Wrapper for SceneryShader.fx
            </summary>
        </member>
        <member name="T:ORTS.ShadowMapShader">
            <summary>
            Wrapper for ShadowMap.fx
            </summary>
        </member>
        <member name="T:ORTS.PopupWindowShader">
            <summary>
            Wrapper for PopupWindow.fx
            </summary>
        </member>
        <member name="T:ORTS.CabShader">
            <summary>
            Wrapper for CabShader.fx
            </summary>
        </member>
        <member name="T:ORTS.PrecipDrawer">
            <summary>
            Precipitation render primitive
            Adapted from code by Jan Vytlačil.
            </summary>
        </member>
        <member name="M:ORTS.PrecipDrawer.#ctor(ORTS.Viewer3D)">
            <summary>
            PrecipDrawer constructor
            </summary>
        </member>
        <member name="M:ORTS.PrecipDrawer.PrepareFrame(ORTS.RenderFrame,ORTS.ElapsedTime)">
            <summary>
            Used to update information affecting the precipitation particles
            </summary>
        </member>
        <member name="M:ORTS.PrecipDrawer.Reset">
            <summary>
            Reset the particle array upon any event that inerrupts or alters the time clock.
            </summary>
        </member>
        <member name="M:ORTS.PrecipMesh.#ctor(ORTS.RenderProcess)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:ORTS.PrecipMesh.VertexPointSprite">
            <summary>
            Custom precipitation sprite vertex format.
            </summary>
        </member>
        <member name="M:ORTS.PrecipMesh.VertexPointSprite.#ctor(Microsoft.Xna.Framework.Vector3,System.Single,System.Single,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Precipitaiton vertex constructor.
            </summary>
            <param name="position">particle position</param>
            <param name="pointSize">particle size</param>
            <param name="time">time of particle initialization</param>
            <param name="wind">wind direction</param>
        </member>
        <member name="M:ORTS.AITrain.AIUpdate(System.Single,System.Double)">
            <summary>
            Update function for a single AI train.
            Performs stop processing if a planned stop is made.
            Then moves the train, calculates target accelleration and adjusts the controls.
            </summary>
        </member>
        <member name="M:ORTS.AITrain.CalcNextStopDistance(System.Double)">
            <summary>
            Computes the NextStopDistanceM value, i.e. the distance from one end of the train to the NextStopNode.
            Returns false and performs the NextStopNode action if its past the train end.
            Also checks for possible coupling and sets CoupleOnNextStop and adjusts the distance if any.
            </summary>
        </member>
        <member name="M:ORTS.AITrain.FindStopNode(ORTS.AIPathNode,System.Single)">
            <summary>
            Finds the next path node the train should stop at.
            </summary>
        </member>
        <member name="M:ORTS.AITrain.FindPrevNode(ORTS.AIPathNode)">
            <summary>
            Finds the path node before target.
            </summary>
        </member>
        <member name="M:ORTS.AITrain.HandleNodeAction(ORTS.AIPathNode,System.Double)">
            <summary>
            Performs any special processing based on the type of node.
            Returns true if an action was performed.
            </summary>
        </member>
        <member name="M:ORTS.AITrain.Uncouple(System.Int32)">
            <summary>
            Uncouples cars from the AI train and keeps the specified number of cars.
            If nCars is negative, -nCars are counted from the rear and the rear is kept.
            If nCars if zero, the entire train is uncoupled and the AI train will be deleted.
            Returns true if an action was performed.
            </summary>
        </member>
        <member name="M:ORTS.AITrain.CalcAccelMpSS">
            <summary>
            Calculated the desired acceleration given the distance to the next stop.
            </summary>
        </member>
        <member name="M:ORTS.AITrain.AdjustControls(System.Single,System.Single,System.Single)">
            <summary>
            Adjusts the train's throttle and brake controls to try to achieve the
            desired acceleration.  If the desired acceleration cannot be achieved
            using the controls, it is simply added to the speed.
            Adjusting the controls is the easiest way to get sound effects etc. to work right.
            </summary>
        </member>
        <member name="T:ORTS.MSTSSteamLocomotive">
            <summary>
            Adds physics and control for a steam locomotive
            </summary>
        </member>
        <member name="M:ORTS.MSTSSteamLocomotive.Parse(System.String,MSTS.STFReader)">
            <summary>
            Parse the wag file parameters required for the simulator and viewer classes
            </summary>
        </member>
        <member name="M:ORTS.MSTSSteamLocomotive.InitializeFromCopy(ORTS.MSTSWagon)">
            <summary>
            This initializer is called when we are making a new copy of a car already
            loaded in memory.  We use this one to speed up loading by eliminating the
            need to parse the wag file multiple times.
            NOTE:  you must initialize all the same variables as you parsed above
            </summary>
        </member>
        <member name="M:ORTS.MSTSSteamLocomotive.Save(System.IO.BinaryWriter)">
            <summary>
            We are saving the game.  Save anything that we'll need to restore the 
            status later.
            </summary>
        </member>
        <member name="M:ORTS.MSTSSteamLocomotive.Restore(System.IO.BinaryReader)">
            <summary>
            We are restoring a saved game.  The TrainCar class has already
            been initialized.   Restore the game state.
            </summary>
        </member>
        <member name="M:ORTS.MSTSSteamLocomotive.GetViewer(ORTS.Viewer3D)">
            <summary>
            Create a viewer for this locomotive.   Viewers are only attached
            while the locomotive is in viewing range.
            </summary>
        </member>
        <member name="M:ORTS.MSTSSteamLocomotive.Update(System.Single)">
            <summary>
            This is a periodic update to calculate physics 
            parameters and update the base class's MotiveForceN 
            and FrictionForceN values based on throttle settings
            etc for the locomotive.
            </summary>
        </member>
        <member name="M:ORTS.MSTSSteamLocomotive.SignalEvent(ORTS.EventID)">
            <summary>
            Used when someone want to notify us of an event
            </summary>
        </member>
        <member name="T:ORTS.MSTSSteamLocomotiveViewer">
            <summary>
            Adds any special steam loco animation to the basic LocomotiveViewer class
            </summary>
        </member>
        <member name="M:ORTS.MSTSSteamLocomotiveViewer.HandleUserInput(ORTS.ElapsedTime)">
            <summary>
            A keyboard or mouse click has occured. Read the UserInput
            structure to determine what was pressed.
            </summary>
        </member>
        <member name="M:ORTS.MSTSSteamLocomotiveViewer.PrepareFrame(ORTS.RenderFrame,ORTS.ElapsedTime)">
            <summary>
            We are about to display a video frame.  Calculate positions for 
            animated objects, and add their primitives to the RenderFrame list.
            </summary>
        </member>
        <member name="M:ORTS.MSTSSteamLocomotiveViewer.Unload">
            <summary>
            This doesn't function yet.
            </summary>
        </member>
        <member name="M:ORTS.AIPath.#ctor(MSTS.PATFile,MSTS.TDBFile,MSTS.TSectionDatFile,System.String)">
            <summary>
            Creates an AIPath from PAT file information.
            First creates all the nodes and then links them together into a main list
            with optional parallel siding list.
            </summary>
        </member>
        <member name="M:ORTS.AIPath.AlignSwitch(System.Int32,System.Int32)">
            <summary>
            Aligns the switch for the specified juction node so that the specified
            vector node will be used as the selected route.
            </summary>
        </member>
        <member name="M:ORTS.AIPath.SwitchIsAligned(System.Int32,System.Int32)">
            <summary>
            returns true if the switch for the specified juction node is aligned
            so that the specified vector node will be used as the selected route.
            </summary>
        </member>
        <member name="M:ORTS.AIPath.RestoreSwitch(System.Int32)">
            <summary>
            aligns the specified switch to its default/main route.
            </summary>
        </member>
        <member name="M:ORTS.AIPath.TestFacingPoint(System.Int32,System.Int32)">
            <summary>
            returns true if the specified vector node is at the facing point end of
            the specified juction node, else false.
            </summary>
        </member>
        <member name="M:ORTS.AIPath.FindTrackNode(ORTS.AIPathNode,System.Int32)">
            <summary>
            finds the first path node after start that refers to the specified track node.
            </summary>
        </member>
        <member name="M:ORTS.AIPathNode.#ctor(MSTS.TrPathNode,MSTS.TrackPDP,MSTS.TrackDB)">
            <summary>
            Creates a single AIPathNode and initializes everything that do not depend on other nodes.
            The AIPath constructor will initialize the rest.
            </summary>
        </member>
        <member name="M:ORTS.AIPathNode.FindTVNIndex(ORTS.AIPathNode,MSTS.TDBFile,MSTS.TSectionDatFile)">
            <summary>
            Returns the index of the vector node connection this path node to another.
            </summary>
        </member>
        <member name="T:ORTS.Tiles">
            <summary>
            Encapsulates the Tiles folder
            </summary>
        </member>
        <member name="T:ORTS.TileBuffer">
            <summary>
            This class speeds up access to tiles by caching the ones in the vicinity of 
            the most recently used tiles.
            </summary>
        </member>
        <member name="M:ORTS.TileBuffer.#ctor(System.String)">
            <summary>
            Create the buffer
            </summary>
            <param name="tileFolderNameSlash"></param>
        </member>
        <member name="M:ORTS.TileBuffer.GetTile(System.Int32,System.Int32)">
            <summary>
            Get a tile from the buffer at X,Z
            Returns null if their is not tile 
            at the specified coordinates.
            </summary>
            <param name="tileX"></param>
            <param name="tileZ"></param>
            <returns></returns>
        </member>
        <member name="M:ORTS.TileBuffer.GetBuffer(System.Int32,System.Int32)">
            <summary>
            Get the raw buffer contents at the specified coordinates
            Returns null if the tile hasn't been read yet.
            </summary>
            <param name="tileX"></param>
            <param name="tileZ"></param>
            <returns></returns>
        </member>
        <member name="M:ORTS.TileBuffer.Contains(System.Int32,System.Int32)">
            <summary>
            Return true if the buffer encloses these coordinates.
            </summary>
            <param name="tileX"></param>
            <param name="tileZ"></param>
            <returns></returns>
        </member>
        <member name="M:ORTS.TileBuffer.Reposition(System.Int32,System.Int32)">
            <summary>
            Shift the buffer to enclose the specified coordinates.
            </summary>
            <param name="tileX"></param>
            <param name="tileZ"></param>
        </member>
        <member name="T:ORTS.RollingStock.SharedGenericWAGFileManager">
            <summary>
            Utility class to avoid loading multiple copies of the same file.
            </summary>
        </member>
        <member name="T:ORTS.RollingStock.GenericWAGFile">
            <summary>
            This is an abbreviated parse to determine where to direct the file.
            </summary>
        </member>
        <member name="T:MSTS.MSTSPath">
            <summary>
            Deals with the MSTS file structure.
            </summary>
        </member>
        <member name="M:MSTS.MSTSPath.Base">
            <summary>
            Returns the base path of the MSTS installation
            </summary>
            <returns>no trailing \</returns>
        </member>
        <member name="M:MSTS.MSTSPath.RouteFolder(System.String)">
            <summary>
            Returns the route folder with out trailing \
            </summary>
            <param name="route"></param>
            <returns></returns>
        </member>
        <member name="M:MSTS.MSTSPath.TrainSoundPath(System.String,System.String)">
            <summary>
            Given a soundfile reference in a wag or eng file, return the path the sound file
            </summary>
            <param name="wagfilename"></param>
            <param name="soundfile"></param>
            <returns></returns>
        </member>
        <member name="M:MSTS.MSTSPath.SMSSoundPath(System.String,System.String)">
            <summary>
            Given a soundfile reference in a cvf file, return the path to the sound file
            </summary>
        </member>
        <member name="M:ORTS.RenderFrame.AddAutoPrimitive(Microsoft.Xna.Framework.Vector3,System.Single,System.Single,ORTS.Material,ORTS.RenderPrimitive,ORTS.RenderPrimitiveGroup,Microsoft.Xna.Framework.Matrix@,ORTS.ShapeFlags)">
            <summary>
            Automatically adds or culls a <see cref="T:ORTS.RenderPrimitive"/> based on a location, radius and max viewing distance.
            </summary>
            <remarks>
            Must be called from the UpdateProcess thread.
            </remarks>
            <param name="mstsLocation">Center location of the <see cref="T:ORTS.RenderPrimitive"/> in MSTS coordinates.</param>
            <param name="objectRadius">Radius of a sphere containing the whole <see cref="T:ORTS.RenderPrimitive"/>, centered on <paramref name="mstsLocation"/>.</param>
            <param name="objectViewingDistance">Maximum distance from which the <see cref="T:ORTS.RenderPrimitive"/> should be viewable.</param>
            <param name="material"></param>
            <param name="primitive"></param>
            <param name="group"></param>
            <param name="xnaMatrix"></param>
            <param name="flags"></param>
        </member>
        <member name="M:ORTS.RenderFrame.AddPrimitive(ORTS.Material,ORTS.RenderPrimitive,ORTS.RenderPrimitiveGroup,Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Executed in the UpdateProcess thread
            </summary>
        </member>
        <member name="M:ORTS.RenderFrame.AddPrimitive(ORTS.Material,ORTS.RenderPrimitive,ORTS.RenderPrimitiveGroup,Microsoft.Xna.Framework.Matrix@,ORTS.ShapeFlags)">
            <summary>
            Executed in the UpdateProcess thread
            </summary>
        </member>
        <member name="M:ORTS.RenderFrame.AddShadowPrimitive(System.Int32,ORTS.Material,ORTS.RenderPrimitive,Microsoft.Xna.Framework.Matrix@,ORTS.ShapeFlags)">
            <summary>
            Executed in the UpdateProcess thread
            </summary>
        </member>
        <member name="M:ORTS.RenderFrame.Sort">
            <summary>
            Executed in the UpdateProcess thread
            </summary>
        </member>
        <member name="M:ORTS.RenderFrame.Draw(Microsoft.Xna.Framework.Graphics.GraphicsDevice)">
            <summary>
            Draw 
            Executed in the RenderProcess thread 
            </summary>
            <param name="graphicsDevice"></param>
        </member>
        <member name="M:ORTS.RenderFrame.DrawSimple(Microsoft.Xna.Framework.Graphics.GraphicsDevice,System.Boolean)">
            <summary>
            Executed in the RenderProcess thread - simple draw
            </summary>
            <param name="graphicsDevice"></param>
            <param name="logging"></param>
        </member>
        <member name="M:ORTS.ForestDrawer.#ctor(ORTS.Viewer3D,MSTS.ForestObj,ORTS.WorldPosition)">
            <summary>
            ForestDrawer constructor
            </summary>
        </member>
        <member name="M:ORTS.ForestMesh.#ctor(ORTS.RenderProcess,ORTS.Tiles,ORTS.ForestDrawer,MSTS.ForestObj)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:ORTS.ForestMesh.InitForestVertices(ORTS.Tiles,Microsoft.Xna.Framework.Graphics.VertexPositionNormalTexture[])">
            <summary>
            Forest tree array intialization. 
            </summary>
        </member>
        <member name="P:ORTS.Signals.SignalObjects">
            <summary>
            Gets an array of all the SignalObjects.
            </summary>
        </member>
        <member name="M:ORTS.SignalObject.this_sig_mr(ORTS.SignalHead.SIGFN)">
            <summary>
            Returns the most restrictive state of this signal's heads.
            </summary>
        </member>
        <member name="M:ORTS.SignalObject.this_sig_lr(ORTS.SignalHead.SIGFN)">
            <summary>
            Returns the least restrictive state of this signal's heads.
            </summary>
        </member>
        <member name="M:ORTS.SignalObject.Update">
            <summary>
            Perform the update for each head on this signal.
            </summary>
        </member>
        <member name="M:ORTS.SignalObject.DistanceTo(ORTS.TDBTraveller)">
            <summary>
            Returns the distance from the TDBtraveller to this signal. 
            </summary>
        </member>
        <member name="M:ORTS.SignalObject.isSignalHead(MSTS.SignalItem)">
            <summary>
            Check Whether signal head is for this signal.
            </summary>
        </member>
        <member name="M:ORTS.SignalObject.AddHead(System.Int32)">
            <summary>
            Adds a head to this signal.
            </summary>
        </member>
        <member name="M:ORTS.SignalObject.SetSignalType(MSTS.SIGCFGFile)">
            <summary>
            Sets the signal type from the sigcfg file for each signal head.
            </summary>
        </member>
        <member name="M:ORTS.SignalObject.GetMonitorAspect">
            <summary>
            Gets the display aspect for the track monitor.
            </summary>
        </member>
        <member name="P:ORTS.SignalObject.trItem">
            <summary>
            Gets the correspnding TrItem from the TDB.
            </summary>
        </member>
        <member name="T:ORTS.Interlocking.InterlockingTrack">
            <summary>
            Defines an abstraction of a track circuit used within the interlocking system.
            </summary>
        </member>
        <member name="M:ORTS.Interlocking.InterlockingTrack.#ctor(ORTS.Simulator,MSTS.TrackNode)">
            <summary>
            Creates a new InterlockingTrack object.
            </summary>
            <param name="simulator">The Simulator object.</param>
            <param name="node">The underlying object from which to create an InterlockingTrack.</param>
        </member>
        <member name="F:ORTS.Interlocking.InterlockingTrack.tempIsOccupied">
            <summary>
            Used during the update process.
            </summary>
        </member>
        <member name="M:ORTS.Interlocking.InterlockingTrack.Occupy">
            <summary>
            Notify this track that it is occupied by a train.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ORTS.Interlocking.InterlockingTrack.BeginUpdate">
            <summary>
            Prepares the track for possible changes.
            </summary>
        </member>
        <member name="M:ORTS.Interlocking.InterlockingTrack.EndUpdate">
            <summary>
            Informs the track that updating has completed.
            </summary>
        </member>
        <member name="P:ORTS.Interlocking.InterlockingTrack.Node">
            <summary>
            Gets the underlying physical object.
            </summary>
        </member>
        <member name="P:ORTS.Interlocking.InterlockingTrack.IsOccupied">
            <summary>
            True when the track is occupied, false otherwise.
            </summary>
        </member>
        <member name="P:ORTS.Interlocking.InterlockingTrack.CascadeToRight">
            <summary>
            Track reference used to detect opposing routes. 
            </summary>
        </member>
        <member name="P:ORTS.Interlocking.InterlockingTrack.CascadeToLeft">
            <summary>
            Track reference used to detect opposing routes. 
            </summary>
        </member>
        <member name="P:ORTS.Interlocking.InterlockingTrack.CascadeFromRight">
            <summary>
            Track reference used to detect opposing routes. 
            </summary>
        </member>
        <member name="P:ORTS.Interlocking.InterlockingTrack.CascadeFromLeft">
            <summary>
            Track reference used to detect opposing routes. 
            </summary>
        </member>
        <member name="P:ORTS.Interlocking.InterlockingTrack.HasCascadeReference">
            <summary>
            Returns true when this track has any cascade references.
            </summary>
        </member>
        <member name="M:MSTSMath.M.Survey(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single@,System.Single@)">
            <summary>
            Consider a line starting a pX,pZ and heading away at deg from North
            returns lat =  distance of x,z off of the line
            returns lon =  distance of x,z along the line
            </summary>
        </member>
        <member name="M:MSTSMath.M.DistanceToLine(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Given a line described by ax + by + c = 0 where a^2 + b^2 = 1
            Returns the signed distance from x,y to the line.
            From http://softsurfer.com/Archive/algorithm_0102/algorithm_0102.htm
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="c"></param>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:MSTSMath.M.AngleDxDz(System.Single,System.Single)">
            <summary>
            Compute the angle in radians resulting from these delta's
            0 degrees is straight ahead - Dz = 0, Dx = 1;
            </summary>
            <param name="Dx"></param>
            <param name="Dz"></param>
            <returns></returns>
        </member>
        <member name="F:ORTS.Viewer3D.RealTime">
            <summary>
            Monotonically increasing time value (in seconds) for the game/viewer. Starts at 0 and only ever increases, at real-time.
            </summary>
        </member>
        <member name="M:ORTS.Viewer3D.#ctor(ORTS.Simulator)">
            <summary>
            Construct a viewer.  At this time background processes are not running
            and the graphics device is not ready to accept content.
            </summary>
            <param name="simulator"></param>
        </member>
        <member name="M:ORTS.Viewer3D.Save(System.IO.BinaryWriter)">
            <summary>
            Save game
            </summary>
        </member>
        <member name="M:ORTS.Viewer3D.Restore(System.IO.BinaryReader)">
            <summary>
            Restore after game resumes
            </summary>
        </member>
        <member name="M:ORTS.Viewer3D.Configure(ORTS.RenderProcess)">
            <summary>
            Called once before the graphics device is started to configure the 
            graphics card and XNA game engine.
            Executes in the RenderProcess thread.
            </summary>
        </member>
        <member name="M:ORTS.Viewer3D.Initialize(ORTS.RenderProcess)">
            <summary>
            Called once after the graphics device is ready
            to load any static graphics content, background 
            processes haven't started yet.
            </summary>
        </member>
        <member name="M:ORTS.Viewer3D.LoadPrep">
            <summary>
            Called 10 times per second when its safe to read volatile data
            from the simulator and viewer classes in preparation
            for the Load call.  Copy data to local storage for use 
            in the next load call.
            </summary>
        </member>
        <member name="M:ORTS.Viewer3D.Load(ORTS.RenderProcess)">
            <summary>
            Called 10 times a second to load graphics content
            that comes and goes as the player and trains move.
            Called from background LoaderProcess Thread
            Do not access volatile data from the simulator 
            and viewer classes during the Load call ( see
            LoadPrep() )
            </summary>
        </member>
        <member name="M:ORTS.Viewer3D.HandleUserInput(ORTS.ElapsedTime)">
            <summary>
            Called whenever a key or mouse buttin is pressed for handling user input
            elapsedTime represents the the time since the last call to HandleUserInput
            Examine the static class UserInput for mouse and keyboard status
            </summary>
        </member>
        <member name="M:ORTS.Viewer3D.PrepareFrame(ORTS.RenderFrame,ORTS.ElapsedTime)">
            <summary>
            Called every frame to update animations and load the frame contents .
            Note:  this doesn't actually draw on the screen surface, but 
            instead prepares a list of drawing primitives that will be rendered
            later in RenderFrame.Draw() by the RenderProcess thread.
            elapsedTime represents the the time since the last call to PrepareFrame.
            </summary>
        </member>
        <member name="M:ORTS.Viewer3D.Unload(ORTS.RenderProcess)">
            <summary>
            Unload all graphical content and restore memory
            </summary>
        </member>
        <member name="M:ORTS.Viewer3D.ProcessReportError(System.Exception)">
            <summary>
            Report an Exception from a background process (e.g. loader).
            </summary>
            <param name="error"></param>
        </member>
        <member name="M:ORTS.Viewer3D.ReadENVFile">
            <summary>
            Determine the correct environment files for this activity and read it in.
            </summary>
        </member>
        <member name="M:ORTS.Viewer3D.ToggleFullscreen">
            <summary>
            Adjust all projection matrixes and buffer sizes
            </summary>
        </member>
        <member name="M:ORTS.Viewer3D.ScreenHasChanged">
            <summary>
            Return true if the screen has changed dimensions
            </summary>
            <returns></returns>
        </member>
        <member name="M:ORTS.Viewer3D.TryUncoupleAt">
            <summary>
            The user has left clicked with U pressed.   
            If the mouse was over a coupler, then uncouple the car.
            </summary>
        </member>
        <member name="M:ORTS.Viewer3D.TryThrowSwitchAt">
            <summary>
            The user has left clicked with U pressed.   
            If the mouse was over a coupler, then uncouple the car.
            </summary>
        </member>
        <member name="F:ORTS.TrainDrawer.LoadedCars">
            THREAD SAFETY WARNING -
        </member>
        <member name="M:ORTS.TrainDrawer.GetViewer(ORTS.TrainCar)">
            <summary>
            Get the viewer for this car.  If the car doesn't have a viewer, then load it.
            </summary>
            <param name="car"></param>
            <returns></returns>
        </member>
        <member name="M:ORTS.TrainDrawer.LoadPrep">
            <summary>
            Executes in the UpdateProcess thread.
            </summary>
        </member>
        <member name="M:ORTS.TrainDrawer.Load(ORTS.RenderProcess)">
            <summary>
            Executes in the LoaderProcess thread.
            </summary>
        </member>
        <member name="M:ORTS.TrainDrawer.PrepareFrame(ORTS.RenderFrame,ORTS.ElapsedTime)">
            <summary>
            Executes in the UpdateProcess thread.
            </summary>
        </member>
        <member name="M:ORTS.TDBTraveller.MoveTo(System.Int32,System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Advance to the specified point.  If the point isn't ahead
            along the track, return false and don't advance.
            </summary>
        </member>
        <member name="M:ORTS.TDBTraveller.DistanceTo(System.Int32,System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Return the distance along the track to the specified point. 
            Observe the current settings for the switch tracks.
            If the point isn't located ahead along the track, then return -1;
            </summary>
        </member>
        <member name="M:ORTS.TDBTraveller.#ctor(MSTS.TrackNode,MSTS.TrVectorSection,MSTS.TDBFile,MSTS.TSectionDatFile)">
            <summary>
            Creates a forward-travelling TDBTraveller.
            </summary>
            <param name="trackNode">The TrackNode from which to create the TDBTraveller.</param>
            <param name="trackSection">The TrackSection from which to create the TDBTraveller.</param>
            <param name="tdb"></param>
            <param name="tsectiondat"></param>
        </member>
        <member name="M:ORTS.TDBTraveller.StraightSectionInit(System.Int32,System.Int32,System.Single,System.Single)">
            <summary>
            If wx,wz is in this straight section, init the traveller to this location
            otherwise return false
            </summary>
        </member>
        <member name="M:ORTS.TDBTraveller.MoveInCurvedSegment(System.Single,System.Int32,MSTS.TrackSection)">
            <summary>
            MoveInCurvedSegment attempts to move traveler through track section.
            </summary>
            <param name="distanceToGo">Target distance (>0) to move along curve.</param>
            <param name="direction">Forward (1) or reverse (0).</param>
            <param name="TS">Track section object.</param>
            <returns>Remaining distance to go.</returns>
        </member>
        <member name="M:ORTS.TDBTraveller.MSTSInterpolateAlongCurve(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Vector3@)">
            <summary>
            MSTSInterpolateAlongCurve interpolates position along a circular arc.
            (Uses MSTS rigid-body rotation method for curve on a grade.)
            </summary>
            <param name="vPC">Local position vector for Point-of-Curve (PC) in x-z plane.</param>
            <param name="vPC_O">Unit vector in direction from PC to arc center (O).</param>
            <param name="mRotY">Rotation matrix that deflects arc from PC to a point on curve (P).</param>
            <param name="mWorld">Transformation from local to world coordinates.</param>
            <param name="vP">Position vector for desired point on curve (P), returned by reference.</param>
            <returns>Displacement vector from PC to P in world coordinates.</returns>
        </member>
        <member name="M:ORTS.TDBTraveller.MSTSInterpolateAlongStraight(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Vector3@)">
            <summary>
            MSTSInterpolateAlongStraight interpolates position along a straight stretch.
            </summary>
            <param name="vP0">Local position vector for starting point P0 in x-z plane.</param>
            <param name="vP0_P">Unit vector in direction from P0 to P.</param>
            <param name="offset">Distance from P0 to P.</param>
            <param name="mWorld">Transformation from local to world coordinates.</param>
            <param name="vP">Position vector for desired point(P), returned by reference.</param>
            <returns>Displacement vector from P0 to P in world coordinates.</returns>
        </member>
        <member name="M:ORTS.TDBTraveller.MoveInSegment(System.Single)">
            <summary>
            To simplify the calculations, all distances must be positive
            </summary>
            <param name="distanceToGo"></param>
            <returns></returns>
        </member>
        <member name="M:ORTS.TDBTraveller.NextSection">
            <summary>
            Advance into the next section
            which could be a TrVectorSection in a TrVectorNode, a TrJunctionNode, or a TrEndNode.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ORTS.TDBTraveller.NextTrVectorSection">
            <summary>
            Assume the TDBTraveller is traversing a TrVectorNode
            Advance to the next TrVectorSection or return false if there are no more sections
            in the current direction of travel.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ORTS.TDBTraveller.NextTrackNode">
            <summary>
            Advance the TDBTraveller into the next track node.
            which could be a TrVectorNode, a TrJunctionNode, or a TrEndNode
            </summary>
            <returns></returns>
        </member>
        <member name="M:ORTS.TDBTraveller.OverlapDistanceM(ORTS.TDBTraveller,System.Boolean)">
            <summary>
            Returns directed distance between two train ends represented by this traveller and other traveller.
            Returns 1 if the distance is >= 1.
            Returns a positive value if the corresponding trains do not overlap and negative if they do.
            rear should be true if this traveller is the rear end of a train.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MSTS.PATTraveller.#ctor(System.String)">
            <summary>
            Initializes the traveller to the first waypoint 
            in the specified path file.
            </summary>
            <param name="PATFilePath"></param>
        </member>
        <member name="T:MSTS.PATFile">
            <summary>
            Work with consist files, contains an ArrayList of ConsistTrainset
            </summary>
        </member>
        <member name="M:MSTS.PATFile.#ctor(System.String)">
            <summary>
            Open a PAT file, 
            filePath includes full path and extension
            </summary>
            <param name="filePath"></param>
        </member>
    </members>
</doc>
