<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Menu</name>
    </assembly>
    <members>
        <member name="F:ORTS.DetailsForm.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:ORTS.DetailsForm.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:ORTS.DetailsForm.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:ORTS.ExploreForm.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:ORTS.ExploreForm.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:ORTS.ExploreForm.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:ORTS.OptionsForm.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:ORTS.OptionsForm.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:ORTS.OptionsForm.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:ORTS.MainForm.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:ORTS.MainForm.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:ORTS.MainForm.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:MSTS.STFReader">
            <summary>Used for reading data from Structured Text Format (MSTS1 style) files.
            </summary><remarks><para>
            An STF file is whitespace delimitered file, taking the format - {item}{whitespace}[repeated].</para><para>
             </para><para>
            At it's most simple an STF file has the format - {token_item}{whitespace}{data_item}{whitespace}(repeated)</para><para>
            Even, more simplisitically every {data_item} can be a {constant_item}</para>
            <code lang="STF" title="STF Example"><para>
                Example:</para><para>
                name SimpleSTFfile</para><para>
                weight 100</para><para>
                speed 50.25</para>
            </code> <para>
            STF also has a block methodology where a {data_item} following a {token_item} can start with '(' followed by any number of {data_item}s and closed with a ')'.
            The contents of the block are defined in the specific file schema, and not in the STF definition.
            The STF defintion allows that inside a pair of parentheses may be a single {constant_item}, multiple whitespace delimitered {constant_item}s, or a nested {token_item}{data_item} pair (which could contain a further nested block recursively).</para>
            <code lang="STF" title="STF Example"><para>
                Example:</para><para>
                name BlockedSTFfile</para><para>
                root_constant 100</para><para>
                root_block_1</para><para>
                (</para><para>
                      nested_block_1_1</para><para>
                      (</para><para>
                            1</para><para>
                      )</para><para>
                      nested_block_1_2 ( 5 )</para><para>
                )</para><para>
                root_block_2</para><para>
                (</para><para>
                      1 2 3</para><para>
                )</para><para>
                root_block_3 ( a b c )</para>
            </code> <para>
            Numeric {constan_item}s can include a 'unit' suffix, which is handled in the ReadDouble() function.</para><para>
            Within ReadDouble these units are then converted to the standards used throughout OR - meters, newtons, kilograms.</para>
            <code lang="STF" title="STF Example"><para>
                Example:</para><para>
                name STFfileWithUnits</para><para>
                weight 100kg</para><para>
                speed 50mph</para>
            </code> <para>
            Whitespaces can be included within any {item} using a double quotation notation.
            Quoted values also support a trailing addition operator to indicate an append operation of multiple quoted strings.</para><para>
            Although append operations are technically allowed for {token_item}'s this practice is *strongly* discouraged for readability.</para>
            <code lang="STF" title="STF Example"><para>
                Example:</para><para>
                simple_token "Data Item with" + " whitespace"</para><para>
                block_token ( "Data " + "Item 1" "Data Item 2" )</para><para>
                "discouraged_" + "token" -1</para><para>
                Error Example:</para><para>
                error1 "You cannot use append suffix to non quoted " + items</para>
            </code> <para>
            The STF format also supports 3 special {token_item}s - include, comment &amp; skip.</para><list class="bullet">
            <listItem><para>include - must be at the root level (that is to say it cannot be included within a block).
            After an include directive the {constant_item} is a filename relative to the current processing STF file.
            The include token has the effect of in-lining the defined file into the current document.</para></listItem>
            <listItem><para>comment &amp; skip - must be followed by a block which will not be processed in OR</para></listItem>
            </list> <para>
            Finally any token which begins with a '#' character will be ignored, and then the next {data_item} (constant or block) will not be processed.</para>
            </remarks>
            <example>
            !!!TODO!!!
            </example>
            <exception cref="T:MSTS.STFException"><para>
            STF reports errors using the  exception static members</para><para>
            There are three broad categories of error</para><list class="bullet">
            <listItem><para>Failure - Something which prevents loading from continuing, this throws an unhandled exception and drops out of Open Rails.</para></listItem>
            <listItem><para>Error - The data read does not have logical meaning - STFReader does not generate these errors, this is only appropriate STFReader consumers who understand the context of the data being processed</para></listItem>
            <listItem><para>Warning - When an error which can be programatically recovered from should be reported back to the user</para></listItem>
            </list>
            </exception>
        </member>
        <member name="M:MSTS.STFReader.#ctor(System.String)">
            <summary>Open a file, reader the header line, and prepare for STF parsing
            </summary>
            <param name="filename">Filename of the STF file to be opened and parsed.</param>
        </member>
        <member name="M:MSTS.STFReader.#ctor(System.IO.Stream,System.String,System.Text.Encoding)">
            <summary>Use an open stream for STF parsing, this constructor assumes that the SIMIS signature has already been gathered (or there isn't one)
            </summary>
            <param name="inputStream">Stream that will be parsed.</param>
            <param name="fileName">Is only used for error reporting.</param>
            <param name="encoding">One of the Encoding formats, defined as static members in Encoding which return an Encoding type.  Eg. Encoding.ASCII or Encoding.Unicode</param>
        </member>
        <member name="M:MSTS.STFReader.Dispose">
            <summary>Implements the IDisposable interface so this class can be implemented with the 'using(STFReader r = new STFReader(...)) {...}' C# statement.
            </summary>
        </member>
        <member name="M:MSTS.STFReader.Dispose(System.Boolean)">
            <summary>Releases the resources used by the STFReader.
            </summary>
            <param name="disposing">
            <para>true - release managed and unmanaged resources.</para>
            <para>false - release only unmanaged resources.</para>
            </param>
        </member>
        <member name="M:MSTS.STFReader.ReadItem">
            <summary>This is the main function in STFReader, it returns the next whitespace delimited {item} from the STF file.
            </summary>
            <returns>The next {item} from the STF file, any surrounding quotations will be not be returned.</returns>
        </member>
        <member name="M:MSTS.STFReader.StepBackOneItem">
            <summary>Calling this function causes ReadItem() to repeat the last {item} that was read from the STF file
            </summary>
            <remarks>
            <para>The current implementation of StepBackOneItem() only allows for one "step back".</para>
            <para>This means that there each call to StepBackOneItem() must have an intervening call to ReadItem().</para>
            </remarks>
        </member>
        <member name="M:MSTS.STFReader.MustMatch(System.String)">
            <summary>Reports a critical error if the next {item} does not match the target.
            </summary>
            <param name="target">The next {item} contents we are expecting in the STF file.</param>
            <returns>The {item} read from the STF file</returns>
        </member>
        <member name="M:MSTS.STFReader.EndOfBlock">
            <summary>Returns true if the next character is the end of block, or end of file. Consuming the closing ")" all other values are not consumed.
            </summary>
            <remarks>
            <para>An STF block should be enclosed in parenthesis, ie ( {data_item} {data_item} )</para>
            </remarks>
            <returns>
            <para>true - An EOF, or closing parenthesis was found and consumed.</para>
            <para>false - Another type of {item} was found but not consumed.</para>
            </returns>
        </member>
        <member name="M:MSTS.STFReader.SkipBlock">
            <summary>Read a block open (, and then consume the rest of the block without processing.
            If we find an immediate close ), then produce a warning, and return without consuming the parenthesis.
            </summary>
        </member>
        <member name="M:MSTS.STFReader.SkipRestOfBlock">
            <summary>Skip to the end of this block, ignoring any nested blocks
            </summary>
        </member>
        <member name="M:MSTS.STFReader.ReadHex(System.Nullable{System.UInt32})">
            <summary>Read an hexidecimal encoded number {constant_item}
            </summary>
            <param name="default_val">the default value if an unexpected ')' token is found</param>
            <returns>The next {constant_item} from the STF file.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadInt(MSTS.STFReader.UNITS,System.Nullable{System.Int32})">
            <summary>Read an signed integer {constant_item}
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">the default value if an unexpected ')' token is found</param>
            <returns>The next {constant_item} from the STF file, with the suffix normalized to OR units.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadUInt(MSTS.STFReader.UNITS,System.Nullable{System.UInt32})">
            <summary>Read an unsigned integer {constant_item}
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">the default value if an unexpected ')' token is found</param>
            <returns>The next {constant_item} from the STF file, with the suffix normalized to OR units.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadFloat(MSTS.STFReader.UNITS,System.Nullable{System.Single})">
            <summary>Read an single precision floating point number {constant_item}
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">the default value if an unexpected ')' token is found</param>
            <returns>The next {constant_item} from the STF file, with the suffix normalized to OR units.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadDouble(MSTS.STFReader.UNITS,System.Nullable{System.Double})">
            <summary>Read an double precision floating point number {constant_item}
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">the default value if an unexpected ')' token is found</param>
            <returns>The next {constant_item} from the STF file, with the suffix normalized to OR units.</returns>
        </member>
        <member name="M:MSTS.STFReader.ParseUnitSuffix(System.String@,MSTS.STFReader.UNITS)">
            <summary>This function removes known unit suffixes, and returns a scaler to bring the constant into the standard OR units.
            </summary>
            <remarks>This function is marked internal so it can be used to support arithmetic processing once the elements are seperated (eg. 5*2m)
            </remarks>
            <param name="constant">string with suffix, after the function call the suffix is removed.</param>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <returns>The scaler that should be used to modify the constant to standard OR units.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadItemBlock(System.String)">
            <summary>Read an {item} from the STF format '( {item} ... )'
            </summary>
            <param name="default_val">the default value if the item is not found in the block.</param>
            <returns>The first item inside the STF block.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadIntBlock(MSTS.STFReader.UNITS,System.Nullable{System.Int32})">
            <summary>Read an integer constant from the STF format '( {int_constant} ... )'
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">the default value if the constant is not found in the block.</param>
            <returns>The STF block with the first {item} converted to a integer constant.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadUIntBlock(MSTS.STFReader.UNITS,System.Nullable{System.UInt32})">
            <summary>Read an unsigned integer constant from the STF format '( {uint_constant} ... )'
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">the default value if the constant is not found in the block.</param>
            <returns>The STF block with the first {item} converted to a unsigned integer constant.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadFloatBlock(MSTS.STFReader.UNITS,System.Nullable{System.Single})">
            <summary>Read an single precision constant from the STF format '( {float_constant} ... )'
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">the default value if the constant is not found in the block.</param>
            <returns>The STF block with the first {item} converted to a single precision constant.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadDoubleBlock(MSTS.STFReader.UNITS,System.Nullable{System.Double})">
            <summary>Read an double precision constant from the STF format '( {double_constant} ... )'
            </summary>
            <param name="valid_units">Any combination of the UNITS enumeration, to limit the availale suffixes to reasonable values.</param>
            <param name="default_val">the default value if the constant is not found in the block.</param>
            <returns>The STF block with the first {item} converted to a double precision constant.</returns>
        </member>
        <member name="M:MSTS.STFReader.ReadBoolBlock(System.Boolean)">
            <summary>Reads the first item from a block in the STF format '( {double_constant} ... )' and return true if is not-zero or 'true'
            </summary>
            <param name="default_val">the default value if a item is not found in the block.</param>
            <returns><para>true - If the first {item} in the block is non-zero or 'true'.</para>
            <para>false - If the first {item} in the block is zero or 'false'.</para></returns>
        </member>
        <member name="M:MSTS.STFReader.ReadVector3Block(Microsoft.Xna.Framework.Vector3)">
            <summary>Read a Vector3 object in the STF format '( {X} {Y} {Z} ... )'
            </summary>
            <param name="default_val">The default vector if any of the values are not specified</param>
            <returns>The STF block as a Vector3</returns>
        </member>
        <member name="F:MSTS.STFReader.includeReader">
            <summary>includeReader is used recursively in ReadItem() to handle the 'include' token, file include mechanism
            </summary>
        </member>
        <member name="F:MSTS.STFReader.previousItem">
            <summary>Remembers the last returned ReadItem().  If the next {item] is a '(', this is the block name used in the tree.
            </summary>
        </member>
        <member name="F:MSTS.STFReader.tree">
            <summary>A list describing the hierachy of nested block tokens
            </summary>
        </member>
        <member name="F:MSTS.STFReader.tree_cache">
            <summary>The tree cache is used to minimize the calls to StringBuilder when Tree is called repetively for the same hierachy.
            </summary>
        </member>
        <member name="F:MSTS.STFReader.stepbackoneitemFlag">
            <summary>This flag is set in StepBackOneItem(), and causes ReadItem(), to use the stepback* variables to do an item repeat
            </summary>
        </member>
        <member name="F:MSTS.STFReader.itemBuilder">
            <summary>This is really a local variable in the function ReadItem(...) but it is a class member to stop unnecessary memory re-allocations.
            </summary>
        </member>
        <member name="M:MSTS.STFReader.ReadItem(System.Boolean)">
            <summary>Internal Implementation - This is the main function that reads an item from the STF stream.
            </summary>
            <param name="skip_mode">True - we are in a skip function, and so we don't want to do any special token processing.</param>
            <returns>The next item from the STF file</returns>
        </member>
        <member name="M:MSTS.STFReader.UpdateTreeAndStepBack(System.String)">
            <summary>Internal Implementation
            <para>This function is called by ReadItem() for every item read from the STF file (and Included files).</para>
            <para>If a block instuction is found, then tree list is updated.</para>
            <para>As this function is called once per ReadItem() is stores the previous value in stepback* variables (there is additional optimization that we only copy stepbackTree if the tree has changed.</para>
            <para>Now when the stepbackoneitemFlag flag is set, we use the stepback* copies, to move back exactly one item.</para>
            </summary>
            <param name="token"></param>
        </member>
        <member name="P:MSTS.STFReader.EOF">
            <summary>Property that returns true when the EOF has been reached
            </summary>
        </member>
        <member name="P:MSTS.STFReader.FileName">
            <summary>Filename property for the file being parsed - for reporting purposes
            </summary>
        </member>
        <member name="P:MSTS.STFReader.LineNumber">
            <summary>Line Number property for the file being parsed - for reporting purposes
            </summary>
        </member>
        <member name="P:MSTS.STFReader.SIMISsignature">
            <summary>SIMIS header read from the first line of the file being parsed
            </summary>
        </member>
        <member name="P:MSTS.STFReader.Tree">
            <summary>Property returning the last {item} read using ReadItem() prefixed with string describing the nested block hierachy.
            <para>The string returned is formatted 'rootnode(nestednode(childnode(previous_item'.</para>
            </summary>
            <remarks>
            Tree is expensive method of reading STF files (especially for the GC) and should be avoided if possible.
            </remarks>
        </member>
        <member name="F:MSTS.STFReader.STEPBACK.Item">
            <summary>The stepback* variables store the previous state, so StepBackOneItem() can jump back on {item}. stepbackItem « ReadItem() return
            </summary>
        </member>
        <member name="F:MSTS.STFReader.STEPBACK.PrevItem">
            <summary>The stepback* variables store the previous state, so StepBackOneItem() can jump back on {item}. stepbackCurrItem « previousItem
            </summary>
        </member>
        <member name="F:MSTS.STFReader.STEPBACK.Tree">
            <summary>The stepback* variables store the previous state, so StepBackOneItem() can jump back on {item}. stepbackTree « tree
            <para>This item, is optimized, so when value is null it means stepbackTree was the same as Tree, so we don't create unneccessary memory duplicates of lists.</para>
            </summary>
        </member>
        <member name="T:MSTS.MSTSPath">
            <summary>
            Deals with the MSTS file structure.
            </summary>
        </member>
        <member name="M:MSTS.MSTSPath.Base">
            <summary>
            Returns the base path of the MSTS installation
            </summary>
            <returns>no trailing \</returns>
        </member>
        <member name="M:MSTS.MSTSPath.RouteFolder(System.String)">
            <summary>
            Returns the route folder with out trailing \
            </summary>
            <param name="route"></param>
            <returns></returns>
        </member>
        <member name="M:MSTS.MSTSPath.TrainSoundPath(System.String,System.String)">
            <summary>
            Given a soundfile reference in a wag or eng file, return the path the sound file
            </summary>
            <param name="wagfilename"></param>
            <param name="soundfile"></param>
            <returns></returns>
        </member>
        <member name="M:MSTS.MSTSPath.SMSSoundPath(System.String,System.String)">
            <summary>
            Given a soundfile reference in a cvf file, return the path to the sound file
            </summary>
            <param name="wagfilename"></param>
            <param name="soundfile"></param>
            <returns></returns>
        </member>
        <member name="M:ORTS.Program.SetBuildRevision">
            <summary>
            Set up the global Build and Revision variables
            from assembly data and the revision.txt file.
            </summary>
        </member>
        <member name="F:ORTS.FormFolderName.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:ORTS.FormFolderName.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:ORTS.FormFolderName.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:MSTS.ACTFile">
            <summary>
            Summary description for Class1.
            </summary>
        </member>
        <member name="M:MSTS.EventCategoryLocation.#ctor(System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Create a new 'ActivitySuccess' LocationEvent
            </summary>
        </member>
        <member name="M:MSTS.EventCategoryAction.#ctor(System.Int32)">
            <summary>
            Build a default EventTypeAllStops event
            </summary>
        </member>
        <member name="T:ORTS.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ORTS.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ORTS.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
    </members>
</doc>
